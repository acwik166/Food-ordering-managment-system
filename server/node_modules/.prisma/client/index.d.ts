import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw }

/**
 * Prisma Client JS version: 2.5.1
 * Query Engine version: c88925ce44a9b89b4351aec85ba6a28979d2658e
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export declare type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export declare type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends Array<LogLevel | LogDefinition>> = GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]> 

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type Action =
  | 'findOne'
  | 'findMany'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: Action
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Addresses
 * const addresses = await prisma.address.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = keyof T extends 'log' ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Addresses
   * const addresses = await prisma.address.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */
  constructor(optionsArg?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * @deprecated renamed to `$on`
   */
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  $connect(): Promise<void>;
  /**
   * @deprecated renamed to `$connect`
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;
  /**
   * @deprecated renamed to `$disconnect`
   */
  disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * @deprecated renamed to `$executeRaw`
   */
  executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;
 
  /**
   * @deprecated renamed to `$executeRaw`
   */
  queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): addressDelegate;

  /**
   * `prisma.client`: Exposes CRUD operations for the **client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): clientDelegate;

  /**
   * `prisma.dish`: Exposes CRUD operations for the **dish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dishes
    * const dishes = await prisma.dish.findMany()
    * ```
    */
  get dish(): dishDelegate;

  /**
   * `prisma.owneraccount`: Exposes CRUD operations for the **owneraccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owneraccounts
    * const owneraccounts = await prisma.owneraccount.findMany()
    * ```
    */
  get owneraccount(): owneraccountDelegate;

  /**
   * `prisma.restaurant`: Exposes CRUD operations for the **restaurant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restaurants
    * const restaurants = await prisma.restaurant.findMany()
    * ```
    */
  get restaurant(): restaurantDelegate;

  /**
   * `prisma.restaurantaddress`: Exposes CRUD operations for the **restaurantaddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restaurantaddresses
    * const restaurantaddresses = await prisma.restaurantaddress.findMany()
    * ```
    */
  get restaurantaddress(): restaurantaddressDelegate;

  /**
   * `prisma.review`: Exposes CRUD operations for the **review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): reviewDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const SortOrder: {
  asc: 'asc',
  desc: 'desc'
};

export declare type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export declare const AddressDistinctFieldEnum: {
  id: 'id',
  city: 'city',
  street: 'street',
  zip: 'zip',
  client_id: 'client_id'
};

export declare type AddressDistinctFieldEnum = (typeof AddressDistinctFieldEnum)[keyof typeof AddressDistinctFieldEnum]


export declare const OwneraccountDistinctFieldEnum: {
  id: 'id',
  client_id: 'client_id'
};

export declare type OwneraccountDistinctFieldEnum = (typeof OwneraccountDistinctFieldEnum)[keyof typeof OwneraccountDistinctFieldEnum]


export declare const RestaurantDistinctFieldEnum: {
  id: 'id',
  name: 'name',
  type: 'type',
  phone: 'phone',
  delivery: 'delivery',
  deliveryfee: 'deliveryfee',
  owner_id: 'owner_id',
  address_id: 'address_id'
};

export declare type RestaurantDistinctFieldEnum = (typeof RestaurantDistinctFieldEnum)[keyof typeof RestaurantDistinctFieldEnum]


export declare const DishDistinctFieldEnum: {
  id: 'id',
  name: 'name',
  sizes: 'sizes',
  ingredients: 'ingredients',
  price: 'price',
  restaurant_id: 'restaurant_id'
};

export declare type DishDistinctFieldEnum = (typeof DishDistinctFieldEnum)[keyof typeof DishDistinctFieldEnum]


export declare const ReviewDistinctFieldEnum: {
  id: 'id',
  title: 'title',
  description: 'description',
  rating: 'rating',
  client_id: 'client_id',
  restaurant_id: 'restaurant_id'
};

export declare type ReviewDistinctFieldEnum = (typeof ReviewDistinctFieldEnum)[keyof typeof ReviewDistinctFieldEnum]


export declare const ClientDistinctFieldEnum: {
  id: 'id',
  firstname: 'firstname',
  lastname: 'lastname',
  password: 'password',
  email: 'email',
  role: 'role'
};

export declare type ClientDistinctFieldEnum = (typeof ClientDistinctFieldEnum)[keyof typeof ClientDistinctFieldEnum]


export declare const RestaurantaddressDistinctFieldEnum: {
  id: 'id',
  city: 'city',
  street: 'street',
  zip: 'zip'
};

export declare type RestaurantaddressDistinctFieldEnum = (typeof RestaurantaddressDistinctFieldEnum)[keyof typeof RestaurantaddressDistinctFieldEnum]



/**
 * Model address
 */

export type address = {
  id: number
  city: string
  street: string
  zip: string
  client_id: number | null
}


export type AggregateAddress = {
  count: number
  avg: AddressAvgAggregateOutputType | null
  sum: AddressSumAggregateOutputType | null
  min: AddressMinAggregateOutputType | null
  max: AddressMaxAggregateOutputType | null
}

export type AddressAvgAggregateOutputType = {
  id: number
  client_id: number
}

export type AddressSumAggregateOutputType = {
  id: number
  client_id: number | null
}

export type AddressMinAggregateOutputType = {
  id: number
  client_id: number | null
}

export type AddressMaxAggregateOutputType = {
  id: number
  client_id: number | null
}


export type AddressAvgAggregateInputType = {
  id?: true
  client_id?: true
}

export type AddressSumAggregateInputType = {
  id?: true
  client_id?: true
}

export type AddressMinAggregateInputType = {
  id?: true
  client_id?: true
}

export type AddressMaxAggregateInputType = {
  id?: true
  client_id?: true
}

export type AggregateAddressArgs = {
  where?: addressWhereInput
  orderBy?: Enumerable<addressOrderByInput>
  cursor?: addressWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<AddressDistinctFieldEnum>
  count?: true
  avg?: AddressAvgAggregateInputType
  sum?: AddressSumAggregateInputType
  min?: AddressMinAggregateInputType
  max?: AddressMaxAggregateInputType
}

export type GetAddressAggregateType<T extends AggregateAddressArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetAddressAggregateScalarType<T[P]>
}

export type GetAddressAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof AddressAvgAggregateOutputType ? AddressAvgAggregateOutputType[P] : never
}
    
    

export type addressSelect = {
  id?: boolean
  city?: boolean
  street?: boolean
  zip?: boolean
  client_id?: boolean
  client?: boolean | clientArgs
}

export type addressInclude = {
  client?: boolean | clientArgs
}

export type addressGetPayload<
  S extends boolean | null | undefined | addressArgs,
  U = keyof S
> = S extends true
  ? address
  : S extends undefined
  ? never
  : S extends addressArgs | FindManyaddressArgs
  ? 'include' extends U
    ? address  & {
      [P in TrueKeys<S['include']>]:
      P extends 'client'
      ? clientGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof address ? address[P]
: 
      P extends 'client'
      ? clientGetPayload<S['select'][P]> | null : never
    }
  : address
: address


export interface addressDelegate {
  /**
   * Find zero or one Address.
   * @param {FindOneaddressArgs} args - Arguments to find a Address
   * @example
   * // Get one Address
   * const address = await prisma.address.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneaddressArgs>(
    args: Subset<T, FindOneaddressArgs>
  ): CheckSelect<T, Prisma__addressClient<address | null>, Prisma__addressClient<addressGetPayload<T> | null>>
  /**
   * Find zero or more Addresses.
   * @param {FindManyaddressArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Addresses
   * const addresses = await prisma.address.findMany()
   * 
   * // Get first 10 Addresses
   * const addresses = await prisma.address.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyaddressArgs>(
    args?: Subset<T, FindManyaddressArgs>
  ): CheckSelect<T, Promise<Array<address>>, Promise<Array<addressGetPayload<T>>>>
  /**
   * Create a Address.
   * @param {addressCreateArgs} args - Arguments to create a Address.
   * @example
   * // Create one Address
   * const Address = await prisma.address.create({
   *   data: {
   *     // ... data to create a Address
   *   }
   * })
   * 
  **/
  create<T extends addressCreateArgs>(
    args: Subset<T, addressCreateArgs>
  ): CheckSelect<T, Prisma__addressClient<address>, Prisma__addressClient<addressGetPayload<T>>>
  /**
   * Delete a Address.
   * @param {addressDeleteArgs} args - Arguments to delete one Address.
   * @example
   * // Delete one Address
   * const Address = await prisma.address.delete({
   *   where: {
   *     // ... filter to delete one Address
   *   }
   * })
   * 
  **/
  delete<T extends addressDeleteArgs>(
    args: Subset<T, addressDeleteArgs>
  ): CheckSelect<T, Prisma__addressClient<address>, Prisma__addressClient<addressGetPayload<T>>>
  /**
   * Update one Address.
   * @param {addressUpdateArgs} args - Arguments to update one Address.
   * @example
   * // Update one Address
   * const address = await prisma.address.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends addressUpdateArgs>(
    args: Subset<T, addressUpdateArgs>
  ): CheckSelect<T, Prisma__addressClient<address>, Prisma__addressClient<addressGetPayload<T>>>
  /**
   * Delete zero or more Addresses.
   * @param {addressDeleteManyArgs} args - Arguments to filter Addresses to delete.
   * @example
   * // Delete a few Addresses
   * const { count } = await prisma.address.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends addressDeleteManyArgs>(
    args: Subset<T, addressDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Addresses.
   * @param {addressUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Addresses
   * const address = await prisma.address.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends addressUpdateManyArgs>(
    args: Subset<T, addressUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Address.
   * @param {addressUpsertArgs} args - Arguments to update or create a Address.
   * @example
   * // Update or create a Address
   * const address = await prisma.address.upsert({
   *   create: {
   *     // ... data to create a Address
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Address we want to update
   *   }
   * })
  **/
  upsert<T extends addressUpsertArgs>(
    args: Subset<T, addressUpsertArgs>
  ): CheckSelect<T, Prisma__addressClient<address>, Prisma__addressClient<addressGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyaddressArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateAddressArgs>(args: Subset<T, AggregateAddressArgs>): Promise<GetAddressAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for address.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__addressClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  client<T extends clientArgs = {}>(args?: Subset<T, clientArgs>): CheckSelect<T, Prisma__clientClient<client | null>, Prisma__clientClient<clientGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * address findOne
 */
export type FindOneaddressArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
  /**
   * Filter, which address to fetch.
  **/
  where: addressWhereUniqueInput
}


/**
 * address findMany
 */
export type FindManyaddressArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
  /**
   * Filter, which addresses to fetch.
  **/
  where?: addressWhereInput
  /**
   * Determine the order of the addresses to fetch.
  **/
  orderBy?: Enumerable<addressOrderByInput>
  /**
   * Sets the position for listing addresses.
  **/
  cursor?: addressWhereUniqueInput
  /**
   * The number of addresses to fetch. If negative number, it will take addresses before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` addresses.
  **/
  skip?: number
  distinct?: Enumerable<AddressDistinctFieldEnum>
}


/**
 * address create
 */
export type addressCreateArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
  /**
   * The data needed to create a address.
  **/
  data: addressCreateInput
}


/**
 * address update
 */
export type addressUpdateArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
  /**
   * The data needed to update a address.
  **/
  data: addressUpdateInput
  /**
   * Choose, which address to update.
  **/
  where: addressWhereUniqueInput
}


/**
 * address updateMany
 */
export type addressUpdateManyArgs = {
  data: addressUpdateManyMutationInput
  where?: addressWhereInput
}


/**
 * address upsert
 */
export type addressUpsertArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
  /**
   * The filter to search for the address to update in case it exists.
  **/
  where: addressWhereUniqueInput
  /**
   * In case the address found by the `where` argument doesn't exist, create a new address with this data.
  **/
  create: addressCreateInput
  /**
   * In case the address was found with the provided `where` argument, update it with this data.
  **/
  update: addressUpdateInput
}


/**
 * address delete
 */
export type addressDeleteArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
  /**
   * Filter which address to delete.
  **/
  where: addressWhereUniqueInput
}


/**
 * address deleteMany
 */
export type addressDeleteManyArgs = {
  where?: addressWhereInput
}


/**
 * address without action
 */
export type addressArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
}



/**
 * Model client
 */

export type client = {
  id: number
  firstname: string
  lastname: string
  password: string
  email: string
  role: string | null
}


export type AggregateClient = {
  count: number
  avg: ClientAvgAggregateOutputType | null
  sum: ClientSumAggregateOutputType | null
  min: ClientMinAggregateOutputType | null
  max: ClientMaxAggregateOutputType | null
}

export type ClientAvgAggregateOutputType = {
  id: number
}

export type ClientSumAggregateOutputType = {
  id: number
}

export type ClientMinAggregateOutputType = {
  id: number
}

export type ClientMaxAggregateOutputType = {
  id: number
}


export type ClientAvgAggregateInputType = {
  id?: true
}

export type ClientSumAggregateInputType = {
  id?: true
}

export type ClientMinAggregateInputType = {
  id?: true
}

export type ClientMaxAggregateInputType = {
  id?: true
}

export type AggregateClientArgs = {
  where?: clientWhereInput
  orderBy?: Enumerable<clientOrderByInput>
  cursor?: clientWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ClientDistinctFieldEnum>
  count?: true
  avg?: ClientAvgAggregateInputType
  sum?: ClientSumAggregateInputType
  min?: ClientMinAggregateInputType
  max?: ClientMaxAggregateInputType
}

export type GetClientAggregateType<T extends AggregateClientArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetClientAggregateScalarType<T[P]>
}

export type GetClientAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ClientAvgAggregateOutputType ? ClientAvgAggregateOutputType[P] : never
}
    
    

export type clientSelect = {
  id?: boolean
  firstname?: boolean
  lastname?: boolean
  password?: boolean
  email?: boolean
  role?: boolean
  address?: boolean | FindManyaddressArgs
  owneraccount?: boolean | FindManyowneraccountArgs
  restaurant?: boolean | FindManyrestaurantArgs
  review?: boolean | FindManyreviewArgs
}

export type clientInclude = {
  address?: boolean | FindManyaddressArgs
  owneraccount?: boolean | FindManyowneraccountArgs
  restaurant?: boolean | FindManyrestaurantArgs
  review?: boolean | FindManyreviewArgs
}

export type clientGetPayload<
  S extends boolean | null | undefined | clientArgs,
  U = keyof S
> = S extends true
  ? client
  : S extends undefined
  ? never
  : S extends clientArgs | FindManyclientArgs
  ? 'include' extends U
    ? client  & {
      [P in TrueKeys<S['include']>]:
      P extends 'address'
      ? Array<addressGetPayload<S['include'][P]>> :
      P extends 'owneraccount'
      ? Array<owneraccountGetPayload<S['include'][P]>> :
      P extends 'restaurant'
      ? Array<restaurantGetPayload<S['include'][P]>> :
      P extends 'review'
      ? Array<reviewGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof client ? client[P]
: 
      P extends 'address'
      ? Array<addressGetPayload<S['select'][P]>> :
      P extends 'owneraccount'
      ? Array<owneraccountGetPayload<S['select'][P]>> :
      P extends 'restaurant'
      ? Array<restaurantGetPayload<S['select'][P]>> :
      P extends 'review'
      ? Array<reviewGetPayload<S['select'][P]>> : never
    }
  : client
: client


export interface clientDelegate {
  /**
   * Find zero or one Client.
   * @param {FindOneclientArgs} args - Arguments to find a Client
   * @example
   * // Get one Client
   * const client = await prisma.client.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneclientArgs>(
    args: Subset<T, FindOneclientArgs>
  ): CheckSelect<T, Prisma__clientClient<client | null>, Prisma__clientClient<clientGetPayload<T> | null>>
  /**
   * Find zero or more Clients.
   * @param {FindManyclientArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Clients
   * const clients = await prisma.client.findMany()
   * 
   * // Get first 10 Clients
   * const clients = await prisma.client.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyclientArgs>(
    args?: Subset<T, FindManyclientArgs>
  ): CheckSelect<T, Promise<Array<client>>, Promise<Array<clientGetPayload<T>>>>
  /**
   * Create a Client.
   * @param {clientCreateArgs} args - Arguments to create a Client.
   * @example
   * // Create one Client
   * const Client = await prisma.client.create({
   *   data: {
   *     // ... data to create a Client
   *   }
   * })
   * 
  **/
  create<T extends clientCreateArgs>(
    args: Subset<T, clientCreateArgs>
  ): CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>>
  /**
   * Delete a Client.
   * @param {clientDeleteArgs} args - Arguments to delete one Client.
   * @example
   * // Delete one Client
   * const Client = await prisma.client.delete({
   *   where: {
   *     // ... filter to delete one Client
   *   }
   * })
   * 
  **/
  delete<T extends clientDeleteArgs>(
    args: Subset<T, clientDeleteArgs>
  ): CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>>
  /**
   * Update one Client.
   * @param {clientUpdateArgs} args - Arguments to update one Client.
   * @example
   * // Update one Client
   * const client = await prisma.client.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends clientUpdateArgs>(
    args: Subset<T, clientUpdateArgs>
  ): CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>>
  /**
   * Delete zero or more Clients.
   * @param {clientDeleteManyArgs} args - Arguments to filter Clients to delete.
   * @example
   * // Delete a few Clients
   * const { count } = await prisma.client.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends clientDeleteManyArgs>(
    args: Subset<T, clientDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Clients.
   * @param {clientUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Clients
   * const client = await prisma.client.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends clientUpdateManyArgs>(
    args: Subset<T, clientUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Client.
   * @param {clientUpsertArgs} args - Arguments to update or create a Client.
   * @example
   * // Update or create a Client
   * const client = await prisma.client.upsert({
   *   create: {
   *     // ... data to create a Client
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Client we want to update
   *   }
   * })
  **/
  upsert<T extends clientUpsertArgs>(
    args: Subset<T, clientUpsertArgs>
  ): CheckSelect<T, Prisma__clientClient<client>, Prisma__clientClient<clientGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyclientArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateClientArgs>(args: Subset<T, AggregateClientArgs>): Promise<GetClientAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for client.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__clientClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  address<T extends FindManyaddressArgs = {}>(args?: Subset<T, FindManyaddressArgs>): CheckSelect<T, Promise<Array<address>>, Promise<Array<addressGetPayload<T>>>>;

  owneraccount<T extends FindManyowneraccountArgs = {}>(args?: Subset<T, FindManyowneraccountArgs>): CheckSelect<T, Promise<Array<owneraccount>>, Promise<Array<owneraccountGetPayload<T>>>>;

  restaurant<T extends FindManyrestaurantArgs = {}>(args?: Subset<T, FindManyrestaurantArgs>): CheckSelect<T, Promise<Array<restaurant>>, Promise<Array<restaurantGetPayload<T>>>>;

  review<T extends FindManyreviewArgs = {}>(args?: Subset<T, FindManyreviewArgs>): CheckSelect<T, Promise<Array<review>>, Promise<Array<reviewGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * client findOne
 */
export type FindOneclientArgs = {
  /**
   * Select specific fields to fetch from the client
  **/
  select?: clientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: clientInclude | null
  /**
   * Filter, which client to fetch.
  **/
  where: clientWhereUniqueInput
}


/**
 * client findMany
 */
export type FindManyclientArgs = {
  /**
   * Select specific fields to fetch from the client
  **/
  select?: clientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: clientInclude | null
  /**
   * Filter, which clients to fetch.
  **/
  where?: clientWhereInput
  /**
   * Determine the order of the clients to fetch.
  **/
  orderBy?: Enumerable<clientOrderByInput>
  /**
   * Sets the position for listing clients.
  **/
  cursor?: clientWhereUniqueInput
  /**
   * The number of clients to fetch. If negative number, it will take clients before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` clients.
  **/
  skip?: number
  distinct?: Enumerable<ClientDistinctFieldEnum>
}


/**
 * client create
 */
export type clientCreateArgs = {
  /**
   * Select specific fields to fetch from the client
  **/
  select?: clientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: clientInclude | null
  /**
   * The data needed to create a client.
  **/
  data: clientCreateInput
}


/**
 * client update
 */
export type clientUpdateArgs = {
  /**
   * Select specific fields to fetch from the client
  **/
  select?: clientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: clientInclude | null
  /**
   * The data needed to update a client.
  **/
  data: clientUpdateInput
  /**
   * Choose, which client to update.
  **/
  where: clientWhereUniqueInput
}


/**
 * client updateMany
 */
export type clientUpdateManyArgs = {
  data: clientUpdateManyMutationInput
  where?: clientWhereInput
}


/**
 * client upsert
 */
export type clientUpsertArgs = {
  /**
   * Select specific fields to fetch from the client
  **/
  select?: clientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: clientInclude | null
  /**
   * The filter to search for the client to update in case it exists.
  **/
  where: clientWhereUniqueInput
  /**
   * In case the client found by the `where` argument doesn't exist, create a new client with this data.
  **/
  create: clientCreateInput
  /**
   * In case the client was found with the provided `where` argument, update it with this data.
  **/
  update: clientUpdateInput
}


/**
 * client delete
 */
export type clientDeleteArgs = {
  /**
   * Select specific fields to fetch from the client
  **/
  select?: clientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: clientInclude | null
  /**
   * Filter which client to delete.
  **/
  where: clientWhereUniqueInput
}


/**
 * client deleteMany
 */
export type clientDeleteManyArgs = {
  where?: clientWhereInput
}


/**
 * client without action
 */
export type clientArgs = {
  /**
   * Select specific fields to fetch from the client
  **/
  select?: clientSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: clientInclude | null
}



/**
 * Model dish
 */

export type dish = {
  id: number
  name: string
  sizes: string[]
  ingredients: string[]
  price: number
  restaurant_id: number
}


export type AggregateDish = {
  count: number
  avg: DishAvgAggregateOutputType | null
  sum: DishSumAggregateOutputType | null
  min: DishMinAggregateOutputType | null
  max: DishMaxAggregateOutputType | null
}

export type DishAvgAggregateOutputType = {
  id: number
  price: number
  restaurant_id: number
}

export type DishSumAggregateOutputType = {
  id: number
  price: number
  restaurant_id: number
}

export type DishMinAggregateOutputType = {
  id: number
  price: number
  restaurant_id: number
}

export type DishMaxAggregateOutputType = {
  id: number
  price: number
  restaurant_id: number
}


export type DishAvgAggregateInputType = {
  id?: true
  price?: true
  restaurant_id?: true
}

export type DishSumAggregateInputType = {
  id?: true
  price?: true
  restaurant_id?: true
}

export type DishMinAggregateInputType = {
  id?: true
  price?: true
  restaurant_id?: true
}

export type DishMaxAggregateInputType = {
  id?: true
  price?: true
  restaurant_id?: true
}

export type AggregateDishArgs = {
  where?: dishWhereInput
  orderBy?: Enumerable<dishOrderByInput>
  cursor?: dishWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<DishDistinctFieldEnum>
  count?: true
  avg?: DishAvgAggregateInputType
  sum?: DishSumAggregateInputType
  min?: DishMinAggregateInputType
  max?: DishMaxAggregateInputType
}

export type GetDishAggregateType<T extends AggregateDishArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetDishAggregateScalarType<T[P]>
}

export type GetDishAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof DishAvgAggregateOutputType ? DishAvgAggregateOutputType[P] : never
}
    
    

export type dishSelect = {
  id?: boolean
  name?: boolean
  sizes?: boolean
  ingredients?: boolean
  price?: boolean
  restaurant_id?: boolean
  restaurant?: boolean | restaurantArgs
}

export type dishInclude = {
  restaurant?: boolean | restaurantArgs
}

export type dishGetPayload<
  S extends boolean | null | undefined | dishArgs,
  U = keyof S
> = S extends true
  ? dish
  : S extends undefined
  ? never
  : S extends dishArgs | FindManydishArgs
  ? 'include' extends U
    ? dish  & {
      [P in TrueKeys<S['include']>]:
      P extends 'restaurant'
      ? restaurantGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof dish ? dish[P]
: 
      P extends 'restaurant'
      ? restaurantGetPayload<S['select'][P]> : never
    }
  : dish
: dish


export interface dishDelegate {
  /**
   * Find zero or one Dish.
   * @param {FindOnedishArgs} args - Arguments to find a Dish
   * @example
   * // Get one Dish
   * const dish = await prisma.dish.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnedishArgs>(
    args: Subset<T, FindOnedishArgs>
  ): CheckSelect<T, Prisma__dishClient<dish | null>, Prisma__dishClient<dishGetPayload<T> | null>>
  /**
   * Find zero or more Dishes.
   * @param {FindManydishArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Dishes
   * const dishes = await prisma.dish.findMany()
   * 
   * // Get first 10 Dishes
   * const dishes = await prisma.dish.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const dishWithIdOnly = await prisma.dish.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManydishArgs>(
    args?: Subset<T, FindManydishArgs>
  ): CheckSelect<T, Promise<Array<dish>>, Promise<Array<dishGetPayload<T>>>>
  /**
   * Create a Dish.
   * @param {dishCreateArgs} args - Arguments to create a Dish.
   * @example
   * // Create one Dish
   * const Dish = await prisma.dish.create({
   *   data: {
   *     // ... data to create a Dish
   *   }
   * })
   * 
  **/
  create<T extends dishCreateArgs>(
    args: Subset<T, dishCreateArgs>
  ): CheckSelect<T, Prisma__dishClient<dish>, Prisma__dishClient<dishGetPayload<T>>>
  /**
   * Delete a Dish.
   * @param {dishDeleteArgs} args - Arguments to delete one Dish.
   * @example
   * // Delete one Dish
   * const Dish = await prisma.dish.delete({
   *   where: {
   *     // ... filter to delete one Dish
   *   }
   * })
   * 
  **/
  delete<T extends dishDeleteArgs>(
    args: Subset<T, dishDeleteArgs>
  ): CheckSelect<T, Prisma__dishClient<dish>, Prisma__dishClient<dishGetPayload<T>>>
  /**
   * Update one Dish.
   * @param {dishUpdateArgs} args - Arguments to update one Dish.
   * @example
   * // Update one Dish
   * const dish = await prisma.dish.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends dishUpdateArgs>(
    args: Subset<T, dishUpdateArgs>
  ): CheckSelect<T, Prisma__dishClient<dish>, Prisma__dishClient<dishGetPayload<T>>>
  /**
   * Delete zero or more Dishes.
   * @param {dishDeleteManyArgs} args - Arguments to filter Dishes to delete.
   * @example
   * // Delete a few Dishes
   * const { count } = await prisma.dish.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends dishDeleteManyArgs>(
    args: Subset<T, dishDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Dishes.
   * @param {dishUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Dishes
   * const dish = await prisma.dish.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends dishUpdateManyArgs>(
    args: Subset<T, dishUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Dish.
   * @param {dishUpsertArgs} args - Arguments to update or create a Dish.
   * @example
   * // Update or create a Dish
   * const dish = await prisma.dish.upsert({
   *   create: {
   *     // ... data to create a Dish
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Dish we want to update
   *   }
   * })
  **/
  upsert<T extends dishUpsertArgs>(
    args: Subset<T, dishUpsertArgs>
  ): CheckSelect<T, Prisma__dishClient<dish>, Prisma__dishClient<dishGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManydishArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateDishArgs>(args: Subset<T, AggregateDishArgs>): Promise<GetDishAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for dish.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__dishClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  restaurant<T extends restaurantArgs = {}>(args?: Subset<T, restaurantArgs>): CheckSelect<T, Prisma__restaurantClient<restaurant | null>, Prisma__restaurantClient<restaurantGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * dish findOne
 */
export type FindOnedishArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
  /**
   * Filter, which dish to fetch.
  **/
  where: dishWhereUniqueInput
}


/**
 * dish findMany
 */
export type FindManydishArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
  /**
   * Filter, which dishes to fetch.
  **/
  where?: dishWhereInput
  /**
   * Determine the order of the dishes to fetch.
  **/
  orderBy?: Enumerable<dishOrderByInput>
  /**
   * Sets the position for listing dishes.
  **/
  cursor?: dishWhereUniqueInput
  /**
   * The number of dishes to fetch. If negative number, it will take dishes before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` dishes.
  **/
  skip?: number
  distinct?: Enumerable<DishDistinctFieldEnum>
}


/**
 * dish create
 */
export type dishCreateArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
  /**
   * The data needed to create a dish.
  **/
  data: dishCreateInput
}


/**
 * dish update
 */
export type dishUpdateArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
  /**
   * The data needed to update a dish.
  **/
  data: dishUpdateInput
  /**
   * Choose, which dish to update.
  **/
  where: dishWhereUniqueInput
}


/**
 * dish updateMany
 */
export type dishUpdateManyArgs = {
  data: dishUpdateManyMutationInput
  where?: dishWhereInput
}


/**
 * dish upsert
 */
export type dishUpsertArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
  /**
   * The filter to search for the dish to update in case it exists.
  **/
  where: dishWhereUniqueInput
  /**
   * In case the dish found by the `where` argument doesn't exist, create a new dish with this data.
  **/
  create: dishCreateInput
  /**
   * In case the dish was found with the provided `where` argument, update it with this data.
  **/
  update: dishUpdateInput
}


/**
 * dish delete
 */
export type dishDeleteArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
  /**
   * Filter which dish to delete.
  **/
  where: dishWhereUniqueInput
}


/**
 * dish deleteMany
 */
export type dishDeleteManyArgs = {
  where?: dishWhereInput
}


/**
 * dish without action
 */
export type dishArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
}



/**
 * Model owneraccount
 */

export type owneraccount = {
  id: number
  client_id: number | null
}


export type AggregateOwneraccount = {
  count: number
  avg: OwneraccountAvgAggregateOutputType | null
  sum: OwneraccountSumAggregateOutputType | null
  min: OwneraccountMinAggregateOutputType | null
  max: OwneraccountMaxAggregateOutputType | null
}

export type OwneraccountAvgAggregateOutputType = {
  id: number
  client_id: number
}

export type OwneraccountSumAggregateOutputType = {
  id: number
  client_id: number | null
}

export type OwneraccountMinAggregateOutputType = {
  id: number
  client_id: number | null
}

export type OwneraccountMaxAggregateOutputType = {
  id: number
  client_id: number | null
}


export type OwneraccountAvgAggregateInputType = {
  id?: true
  client_id?: true
}

export type OwneraccountSumAggregateInputType = {
  id?: true
  client_id?: true
}

export type OwneraccountMinAggregateInputType = {
  id?: true
  client_id?: true
}

export type OwneraccountMaxAggregateInputType = {
  id?: true
  client_id?: true
}

export type AggregateOwneraccountArgs = {
  where?: owneraccountWhereInput
  orderBy?: Enumerable<owneraccountOrderByInput>
  cursor?: owneraccountWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OwneraccountDistinctFieldEnum>
  count?: true
  avg?: OwneraccountAvgAggregateInputType
  sum?: OwneraccountSumAggregateInputType
  min?: OwneraccountMinAggregateInputType
  max?: OwneraccountMaxAggregateInputType
}

export type GetOwneraccountAggregateType<T extends AggregateOwneraccountArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetOwneraccountAggregateScalarType<T[P]>
}

export type GetOwneraccountAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof OwneraccountAvgAggregateOutputType ? OwneraccountAvgAggregateOutputType[P] : never
}
    
    

export type owneraccountSelect = {
  id?: boolean
  client_id?: boolean
  client?: boolean | clientArgs
}

export type owneraccountInclude = {
  client?: boolean | clientArgs
}

export type owneraccountGetPayload<
  S extends boolean | null | undefined | owneraccountArgs,
  U = keyof S
> = S extends true
  ? owneraccount
  : S extends undefined
  ? never
  : S extends owneraccountArgs | FindManyowneraccountArgs
  ? 'include' extends U
    ? owneraccount  & {
      [P in TrueKeys<S['include']>]:
      P extends 'client'
      ? clientGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof owneraccount ? owneraccount[P]
: 
      P extends 'client'
      ? clientGetPayload<S['select'][P]> | null : never
    }
  : owneraccount
: owneraccount


export interface owneraccountDelegate {
  /**
   * Find zero or one Owneraccount.
   * @param {FindOneowneraccountArgs} args - Arguments to find a Owneraccount
   * @example
   * // Get one Owneraccount
   * const owneraccount = await prisma.owneraccount.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneowneraccountArgs>(
    args: Subset<T, FindOneowneraccountArgs>
  ): CheckSelect<T, Prisma__owneraccountClient<owneraccount | null>, Prisma__owneraccountClient<owneraccountGetPayload<T> | null>>
  /**
   * Find zero or more Owneraccounts.
   * @param {FindManyowneraccountArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Owneraccounts
   * const owneraccounts = await prisma.owneraccount.findMany()
   * 
   * // Get first 10 Owneraccounts
   * const owneraccounts = await prisma.owneraccount.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const owneraccountWithIdOnly = await prisma.owneraccount.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyowneraccountArgs>(
    args?: Subset<T, FindManyowneraccountArgs>
  ): CheckSelect<T, Promise<Array<owneraccount>>, Promise<Array<owneraccountGetPayload<T>>>>
  /**
   * Create a Owneraccount.
   * @param {owneraccountCreateArgs} args - Arguments to create a Owneraccount.
   * @example
   * // Create one Owneraccount
   * const Owneraccount = await prisma.owneraccount.create({
   *   data: {
   *     // ... data to create a Owneraccount
   *   }
   * })
   * 
  **/
  create<T extends owneraccountCreateArgs>(
    args: Subset<T, owneraccountCreateArgs>
  ): CheckSelect<T, Prisma__owneraccountClient<owneraccount>, Prisma__owneraccountClient<owneraccountGetPayload<T>>>
  /**
   * Delete a Owneraccount.
   * @param {owneraccountDeleteArgs} args - Arguments to delete one Owneraccount.
   * @example
   * // Delete one Owneraccount
   * const Owneraccount = await prisma.owneraccount.delete({
   *   where: {
   *     // ... filter to delete one Owneraccount
   *   }
   * })
   * 
  **/
  delete<T extends owneraccountDeleteArgs>(
    args: Subset<T, owneraccountDeleteArgs>
  ): CheckSelect<T, Prisma__owneraccountClient<owneraccount>, Prisma__owneraccountClient<owneraccountGetPayload<T>>>
  /**
   * Update one Owneraccount.
   * @param {owneraccountUpdateArgs} args - Arguments to update one Owneraccount.
   * @example
   * // Update one Owneraccount
   * const owneraccount = await prisma.owneraccount.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends owneraccountUpdateArgs>(
    args: Subset<T, owneraccountUpdateArgs>
  ): CheckSelect<T, Prisma__owneraccountClient<owneraccount>, Prisma__owneraccountClient<owneraccountGetPayload<T>>>
  /**
   * Delete zero or more Owneraccounts.
   * @param {owneraccountDeleteManyArgs} args - Arguments to filter Owneraccounts to delete.
   * @example
   * // Delete a few Owneraccounts
   * const { count } = await prisma.owneraccount.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends owneraccountDeleteManyArgs>(
    args: Subset<T, owneraccountDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Owneraccounts.
   * @param {owneraccountUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Owneraccounts
   * const owneraccount = await prisma.owneraccount.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends owneraccountUpdateManyArgs>(
    args: Subset<T, owneraccountUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Owneraccount.
   * @param {owneraccountUpsertArgs} args - Arguments to update or create a Owneraccount.
   * @example
   * // Update or create a Owneraccount
   * const owneraccount = await prisma.owneraccount.upsert({
   *   create: {
   *     // ... data to create a Owneraccount
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Owneraccount we want to update
   *   }
   * })
  **/
  upsert<T extends owneraccountUpsertArgs>(
    args: Subset<T, owneraccountUpsertArgs>
  ): CheckSelect<T, Prisma__owneraccountClient<owneraccount>, Prisma__owneraccountClient<owneraccountGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyowneraccountArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateOwneraccountArgs>(args: Subset<T, AggregateOwneraccountArgs>): Promise<GetOwneraccountAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for owneraccount.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__owneraccountClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  client<T extends clientArgs = {}>(args?: Subset<T, clientArgs>): CheckSelect<T, Prisma__clientClient<client | null>, Prisma__clientClient<clientGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * owneraccount findOne
 */
export type FindOneowneraccountArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
  /**
   * Filter, which owneraccount to fetch.
  **/
  where: owneraccountWhereUniqueInput
}


/**
 * owneraccount findMany
 */
export type FindManyowneraccountArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
  /**
   * Filter, which owneraccounts to fetch.
  **/
  where?: owneraccountWhereInput
  /**
   * Determine the order of the owneraccounts to fetch.
  **/
  orderBy?: Enumerable<owneraccountOrderByInput>
  /**
   * Sets the position for listing owneraccounts.
  **/
  cursor?: owneraccountWhereUniqueInput
  /**
   * The number of owneraccounts to fetch. If negative number, it will take owneraccounts before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` owneraccounts.
  **/
  skip?: number
  distinct?: Enumerable<OwneraccountDistinctFieldEnum>
}


/**
 * owneraccount create
 */
export type owneraccountCreateArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
  /**
   * The data needed to create a owneraccount.
  **/
  data: owneraccountCreateInput
}


/**
 * owneraccount update
 */
export type owneraccountUpdateArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
  /**
   * The data needed to update a owneraccount.
  **/
  data: owneraccountUpdateInput
  /**
   * Choose, which owneraccount to update.
  **/
  where: owneraccountWhereUniqueInput
}


/**
 * owneraccount updateMany
 */
export type owneraccountUpdateManyArgs = {
  data: owneraccountUpdateManyMutationInput
  where?: owneraccountWhereInput
}


/**
 * owneraccount upsert
 */
export type owneraccountUpsertArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
  /**
   * The filter to search for the owneraccount to update in case it exists.
  **/
  where: owneraccountWhereUniqueInput
  /**
   * In case the owneraccount found by the `where` argument doesn't exist, create a new owneraccount with this data.
  **/
  create: owneraccountCreateInput
  /**
   * In case the owneraccount was found with the provided `where` argument, update it with this data.
  **/
  update: owneraccountUpdateInput
}


/**
 * owneraccount delete
 */
export type owneraccountDeleteArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
  /**
   * Filter which owneraccount to delete.
  **/
  where: owneraccountWhereUniqueInput
}


/**
 * owneraccount deleteMany
 */
export type owneraccountDeleteManyArgs = {
  where?: owneraccountWhereInput
}


/**
 * owneraccount without action
 */
export type owneraccountArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
}



/**
 * Model restaurant
 */

export type restaurant = {
  id: number
  name: string
  type: string
  phone: string
  delivery: number
  deliveryfee: number
  owner_id: number
  address_id: number
}


export type AggregateRestaurant = {
  count: number
  avg: RestaurantAvgAggregateOutputType | null
  sum: RestaurantSumAggregateOutputType | null
  min: RestaurantMinAggregateOutputType | null
  max: RestaurantMaxAggregateOutputType | null
}

export type RestaurantAvgAggregateOutputType = {
  id: number
  delivery: number
  deliveryfee: number
  owner_id: number
  address_id: number
}

export type RestaurantSumAggregateOutputType = {
  id: number
  delivery: number
  deliveryfee: number
  owner_id: number
  address_id: number
}

export type RestaurantMinAggregateOutputType = {
  id: number
  delivery: number
  deliveryfee: number
  owner_id: number
  address_id: number
}

export type RestaurantMaxAggregateOutputType = {
  id: number
  delivery: number
  deliveryfee: number
  owner_id: number
  address_id: number
}


export type RestaurantAvgAggregateInputType = {
  id?: true
  delivery?: true
  deliveryfee?: true
  owner_id?: true
  address_id?: true
}

export type RestaurantSumAggregateInputType = {
  id?: true
  delivery?: true
  deliveryfee?: true
  owner_id?: true
  address_id?: true
}

export type RestaurantMinAggregateInputType = {
  id?: true
  delivery?: true
  deliveryfee?: true
  owner_id?: true
  address_id?: true
}

export type RestaurantMaxAggregateInputType = {
  id?: true
  delivery?: true
  deliveryfee?: true
  owner_id?: true
  address_id?: true
}

export type AggregateRestaurantArgs = {
  where?: restaurantWhereInput
  orderBy?: Enumerable<restaurantOrderByInput>
  cursor?: restaurantWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<RestaurantDistinctFieldEnum>
  count?: true
  avg?: RestaurantAvgAggregateInputType
  sum?: RestaurantSumAggregateInputType
  min?: RestaurantMinAggregateInputType
  max?: RestaurantMaxAggregateInputType
}

export type GetRestaurantAggregateType<T extends AggregateRestaurantArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetRestaurantAggregateScalarType<T[P]>
}

export type GetRestaurantAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof RestaurantAvgAggregateOutputType ? RestaurantAvgAggregateOutputType[P] : never
}
    
    

export type restaurantSelect = {
  id?: boolean
  name?: boolean
  type?: boolean
  phone?: boolean
  delivery?: boolean
  deliveryfee?: boolean
  owner_id?: boolean
  address_id?: boolean
  restaurantaddress?: boolean | restaurantaddressArgs
  client?: boolean | clientArgs
  dish?: boolean | FindManydishArgs
  review?: boolean | FindManyreviewArgs
}

export type restaurantInclude = {
  restaurantaddress?: boolean | restaurantaddressArgs
  client?: boolean | clientArgs
  dish?: boolean | FindManydishArgs
  review?: boolean | FindManyreviewArgs
}

export type restaurantGetPayload<
  S extends boolean | null | undefined | restaurantArgs,
  U = keyof S
> = S extends true
  ? restaurant
  : S extends undefined
  ? never
  : S extends restaurantArgs | FindManyrestaurantArgs
  ? 'include' extends U
    ? restaurant  & {
      [P in TrueKeys<S['include']>]:
      P extends 'restaurantaddress'
      ? restaurantaddressGetPayload<S['include'][P]> :
      P extends 'client'
      ? clientGetPayload<S['include'][P]> :
      P extends 'dish'
      ? Array<dishGetPayload<S['include'][P]>> :
      P extends 'review'
      ? Array<reviewGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof restaurant ? restaurant[P]
: 
      P extends 'restaurantaddress'
      ? restaurantaddressGetPayload<S['select'][P]> :
      P extends 'client'
      ? clientGetPayload<S['select'][P]> :
      P extends 'dish'
      ? Array<dishGetPayload<S['select'][P]>> :
      P extends 'review'
      ? Array<reviewGetPayload<S['select'][P]>> : never
    }
  : restaurant
: restaurant


export interface restaurantDelegate {
  /**
   * Find zero or one Restaurant.
   * @param {FindOnerestaurantArgs} args - Arguments to find a Restaurant
   * @example
   * // Get one Restaurant
   * const restaurant = await prisma.restaurant.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnerestaurantArgs>(
    args: Subset<T, FindOnerestaurantArgs>
  ): CheckSelect<T, Prisma__restaurantClient<restaurant | null>, Prisma__restaurantClient<restaurantGetPayload<T> | null>>
  /**
   * Find zero or more Restaurants.
   * @param {FindManyrestaurantArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Restaurants
   * const restaurants = await prisma.restaurant.findMany()
   * 
   * // Get first 10 Restaurants
   * const restaurants = await prisma.restaurant.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const restaurantWithIdOnly = await prisma.restaurant.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyrestaurantArgs>(
    args?: Subset<T, FindManyrestaurantArgs>
  ): CheckSelect<T, Promise<Array<restaurant>>, Promise<Array<restaurantGetPayload<T>>>>
  /**
   * Create a Restaurant.
   * @param {restaurantCreateArgs} args - Arguments to create a Restaurant.
   * @example
   * // Create one Restaurant
   * const Restaurant = await prisma.restaurant.create({
   *   data: {
   *     // ... data to create a Restaurant
   *   }
   * })
   * 
  **/
  create<T extends restaurantCreateArgs>(
    args: Subset<T, restaurantCreateArgs>
  ): CheckSelect<T, Prisma__restaurantClient<restaurant>, Prisma__restaurantClient<restaurantGetPayload<T>>>
  /**
   * Delete a Restaurant.
   * @param {restaurantDeleteArgs} args - Arguments to delete one Restaurant.
   * @example
   * // Delete one Restaurant
   * const Restaurant = await prisma.restaurant.delete({
   *   where: {
   *     // ... filter to delete one Restaurant
   *   }
   * })
   * 
  **/
  delete<T extends restaurantDeleteArgs>(
    args: Subset<T, restaurantDeleteArgs>
  ): CheckSelect<T, Prisma__restaurantClient<restaurant>, Prisma__restaurantClient<restaurantGetPayload<T>>>
  /**
   * Update one Restaurant.
   * @param {restaurantUpdateArgs} args - Arguments to update one Restaurant.
   * @example
   * // Update one Restaurant
   * const restaurant = await prisma.restaurant.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends restaurantUpdateArgs>(
    args: Subset<T, restaurantUpdateArgs>
  ): CheckSelect<T, Prisma__restaurantClient<restaurant>, Prisma__restaurantClient<restaurantGetPayload<T>>>
  /**
   * Delete zero or more Restaurants.
   * @param {restaurantDeleteManyArgs} args - Arguments to filter Restaurants to delete.
   * @example
   * // Delete a few Restaurants
   * const { count } = await prisma.restaurant.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends restaurantDeleteManyArgs>(
    args: Subset<T, restaurantDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Restaurants.
   * @param {restaurantUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Restaurants
   * const restaurant = await prisma.restaurant.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends restaurantUpdateManyArgs>(
    args: Subset<T, restaurantUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Restaurant.
   * @param {restaurantUpsertArgs} args - Arguments to update or create a Restaurant.
   * @example
   * // Update or create a Restaurant
   * const restaurant = await prisma.restaurant.upsert({
   *   create: {
   *     // ... data to create a Restaurant
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Restaurant we want to update
   *   }
   * })
  **/
  upsert<T extends restaurantUpsertArgs>(
    args: Subset<T, restaurantUpsertArgs>
  ): CheckSelect<T, Prisma__restaurantClient<restaurant>, Prisma__restaurantClient<restaurantGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyrestaurantArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateRestaurantArgs>(args: Subset<T, AggregateRestaurantArgs>): Promise<GetRestaurantAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for restaurant.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__restaurantClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  restaurantaddress<T extends restaurantaddressArgs = {}>(args?: Subset<T, restaurantaddressArgs>): CheckSelect<T, Prisma__restaurantaddressClient<restaurantaddress | null>, Prisma__restaurantaddressClient<restaurantaddressGetPayload<T> | null>>;

  client<T extends clientArgs = {}>(args?: Subset<T, clientArgs>): CheckSelect<T, Prisma__clientClient<client | null>, Prisma__clientClient<clientGetPayload<T> | null>>;

  dish<T extends FindManydishArgs = {}>(args?: Subset<T, FindManydishArgs>): CheckSelect<T, Promise<Array<dish>>, Promise<Array<dishGetPayload<T>>>>;

  review<T extends FindManyreviewArgs = {}>(args?: Subset<T, FindManyreviewArgs>): CheckSelect<T, Promise<Array<review>>, Promise<Array<reviewGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * restaurant findOne
 */
export type FindOnerestaurantArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
  /**
   * Filter, which restaurant to fetch.
  **/
  where: restaurantWhereUniqueInput
}


/**
 * restaurant findMany
 */
export type FindManyrestaurantArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
  /**
   * Filter, which restaurants to fetch.
  **/
  where?: restaurantWhereInput
  /**
   * Determine the order of the restaurants to fetch.
  **/
  orderBy?: Enumerable<restaurantOrderByInput>
  /**
   * Sets the position for listing restaurants.
  **/
  cursor?: restaurantWhereUniqueInput
  /**
   * The number of restaurants to fetch. If negative number, it will take restaurants before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` restaurants.
  **/
  skip?: number
  distinct?: Enumerable<RestaurantDistinctFieldEnum>
}


/**
 * restaurant create
 */
export type restaurantCreateArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
  /**
   * The data needed to create a restaurant.
  **/
  data: restaurantCreateInput
}


/**
 * restaurant update
 */
export type restaurantUpdateArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
  /**
   * The data needed to update a restaurant.
  **/
  data: restaurantUpdateInput
  /**
   * Choose, which restaurant to update.
  **/
  where: restaurantWhereUniqueInput
}


/**
 * restaurant updateMany
 */
export type restaurantUpdateManyArgs = {
  data: restaurantUpdateManyMutationInput
  where?: restaurantWhereInput
}


/**
 * restaurant upsert
 */
export type restaurantUpsertArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
  /**
   * The filter to search for the restaurant to update in case it exists.
  **/
  where: restaurantWhereUniqueInput
  /**
   * In case the restaurant found by the `where` argument doesn't exist, create a new restaurant with this data.
  **/
  create: restaurantCreateInput
  /**
   * In case the restaurant was found with the provided `where` argument, update it with this data.
  **/
  update: restaurantUpdateInput
}


/**
 * restaurant delete
 */
export type restaurantDeleteArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
  /**
   * Filter which restaurant to delete.
  **/
  where: restaurantWhereUniqueInput
}


/**
 * restaurant deleteMany
 */
export type restaurantDeleteManyArgs = {
  where?: restaurantWhereInput
}


/**
 * restaurant without action
 */
export type restaurantArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
}



/**
 * Model restaurantaddress
 */

export type restaurantaddress = {
  id: number
  city: string
  street: string
  zip: string
}


export type AggregateRestaurantaddress = {
  count: number
  avg: RestaurantaddressAvgAggregateOutputType | null
  sum: RestaurantaddressSumAggregateOutputType | null
  min: RestaurantaddressMinAggregateOutputType | null
  max: RestaurantaddressMaxAggregateOutputType | null
}

export type RestaurantaddressAvgAggregateOutputType = {
  id: number
}

export type RestaurantaddressSumAggregateOutputType = {
  id: number
}

export type RestaurantaddressMinAggregateOutputType = {
  id: number
}

export type RestaurantaddressMaxAggregateOutputType = {
  id: number
}


export type RestaurantaddressAvgAggregateInputType = {
  id?: true
}

export type RestaurantaddressSumAggregateInputType = {
  id?: true
}

export type RestaurantaddressMinAggregateInputType = {
  id?: true
}

export type RestaurantaddressMaxAggregateInputType = {
  id?: true
}

export type AggregateRestaurantaddressArgs = {
  where?: restaurantaddressWhereInput
  orderBy?: Enumerable<restaurantaddressOrderByInput>
  cursor?: restaurantaddressWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<RestaurantaddressDistinctFieldEnum>
  count?: true
  avg?: RestaurantaddressAvgAggregateInputType
  sum?: RestaurantaddressSumAggregateInputType
  min?: RestaurantaddressMinAggregateInputType
  max?: RestaurantaddressMaxAggregateInputType
}

export type GetRestaurantaddressAggregateType<T extends AggregateRestaurantaddressArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetRestaurantaddressAggregateScalarType<T[P]>
}

export type GetRestaurantaddressAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof RestaurantaddressAvgAggregateOutputType ? RestaurantaddressAvgAggregateOutputType[P] : never
}
    
    

export type restaurantaddressSelect = {
  id?: boolean
  city?: boolean
  street?: boolean
  zip?: boolean
  restaurant?: boolean | FindManyrestaurantArgs
}

export type restaurantaddressInclude = {
  restaurant?: boolean | FindManyrestaurantArgs
}

export type restaurantaddressGetPayload<
  S extends boolean | null | undefined | restaurantaddressArgs,
  U = keyof S
> = S extends true
  ? restaurantaddress
  : S extends undefined
  ? never
  : S extends restaurantaddressArgs | FindManyrestaurantaddressArgs
  ? 'include' extends U
    ? restaurantaddress  & {
      [P in TrueKeys<S['include']>]:
      P extends 'restaurant'
      ? Array<restaurantGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof restaurantaddress ? restaurantaddress[P]
: 
      P extends 'restaurant'
      ? Array<restaurantGetPayload<S['select'][P]>> : never
    }
  : restaurantaddress
: restaurantaddress


export interface restaurantaddressDelegate {
  /**
   * Find zero or one Restaurantaddress.
   * @param {FindOnerestaurantaddressArgs} args - Arguments to find a Restaurantaddress
   * @example
   * // Get one Restaurantaddress
   * const restaurantaddress = await prisma.restaurantaddress.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnerestaurantaddressArgs>(
    args: Subset<T, FindOnerestaurantaddressArgs>
  ): CheckSelect<T, Prisma__restaurantaddressClient<restaurantaddress | null>, Prisma__restaurantaddressClient<restaurantaddressGetPayload<T> | null>>
  /**
   * Find zero or more Restaurantaddresses.
   * @param {FindManyrestaurantaddressArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Restaurantaddresses
   * const restaurantaddresses = await prisma.restaurantaddress.findMany()
   * 
   * // Get first 10 Restaurantaddresses
   * const restaurantaddresses = await prisma.restaurantaddress.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const restaurantaddressWithIdOnly = await prisma.restaurantaddress.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyrestaurantaddressArgs>(
    args?: Subset<T, FindManyrestaurantaddressArgs>
  ): CheckSelect<T, Promise<Array<restaurantaddress>>, Promise<Array<restaurantaddressGetPayload<T>>>>
  /**
   * Create a Restaurantaddress.
   * @param {restaurantaddressCreateArgs} args - Arguments to create a Restaurantaddress.
   * @example
   * // Create one Restaurantaddress
   * const Restaurantaddress = await prisma.restaurantaddress.create({
   *   data: {
   *     // ... data to create a Restaurantaddress
   *   }
   * })
   * 
  **/
  create<T extends restaurantaddressCreateArgs>(
    args: Subset<T, restaurantaddressCreateArgs>
  ): CheckSelect<T, Prisma__restaurantaddressClient<restaurantaddress>, Prisma__restaurantaddressClient<restaurantaddressGetPayload<T>>>
  /**
   * Delete a Restaurantaddress.
   * @param {restaurantaddressDeleteArgs} args - Arguments to delete one Restaurantaddress.
   * @example
   * // Delete one Restaurantaddress
   * const Restaurantaddress = await prisma.restaurantaddress.delete({
   *   where: {
   *     // ... filter to delete one Restaurantaddress
   *   }
   * })
   * 
  **/
  delete<T extends restaurantaddressDeleteArgs>(
    args: Subset<T, restaurantaddressDeleteArgs>
  ): CheckSelect<T, Prisma__restaurantaddressClient<restaurantaddress>, Prisma__restaurantaddressClient<restaurantaddressGetPayload<T>>>
  /**
   * Update one Restaurantaddress.
   * @param {restaurantaddressUpdateArgs} args - Arguments to update one Restaurantaddress.
   * @example
   * // Update one Restaurantaddress
   * const restaurantaddress = await prisma.restaurantaddress.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends restaurantaddressUpdateArgs>(
    args: Subset<T, restaurantaddressUpdateArgs>
  ): CheckSelect<T, Prisma__restaurantaddressClient<restaurantaddress>, Prisma__restaurantaddressClient<restaurantaddressGetPayload<T>>>
  /**
   * Delete zero or more Restaurantaddresses.
   * @param {restaurantaddressDeleteManyArgs} args - Arguments to filter Restaurantaddresses to delete.
   * @example
   * // Delete a few Restaurantaddresses
   * const { count } = await prisma.restaurantaddress.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends restaurantaddressDeleteManyArgs>(
    args: Subset<T, restaurantaddressDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Restaurantaddresses.
   * @param {restaurantaddressUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Restaurantaddresses
   * const restaurantaddress = await prisma.restaurantaddress.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends restaurantaddressUpdateManyArgs>(
    args: Subset<T, restaurantaddressUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Restaurantaddress.
   * @param {restaurantaddressUpsertArgs} args - Arguments to update or create a Restaurantaddress.
   * @example
   * // Update or create a Restaurantaddress
   * const restaurantaddress = await prisma.restaurantaddress.upsert({
   *   create: {
   *     // ... data to create a Restaurantaddress
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Restaurantaddress we want to update
   *   }
   * })
  **/
  upsert<T extends restaurantaddressUpsertArgs>(
    args: Subset<T, restaurantaddressUpsertArgs>
  ): CheckSelect<T, Prisma__restaurantaddressClient<restaurantaddress>, Prisma__restaurantaddressClient<restaurantaddressGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyrestaurantaddressArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateRestaurantaddressArgs>(args: Subset<T, AggregateRestaurantaddressArgs>): Promise<GetRestaurantaddressAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for restaurantaddress.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__restaurantaddressClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  restaurant<T extends FindManyrestaurantArgs = {}>(args?: Subset<T, FindManyrestaurantArgs>): CheckSelect<T, Promise<Array<restaurant>>, Promise<Array<restaurantGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * restaurantaddress findOne
 */
export type FindOnerestaurantaddressArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
  /**
   * Filter, which restaurantaddress to fetch.
  **/
  where: restaurantaddressWhereUniqueInput
}


/**
 * restaurantaddress findMany
 */
export type FindManyrestaurantaddressArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
  /**
   * Filter, which restaurantaddresses to fetch.
  **/
  where?: restaurantaddressWhereInput
  /**
   * Determine the order of the restaurantaddresses to fetch.
  **/
  orderBy?: Enumerable<restaurantaddressOrderByInput>
  /**
   * Sets the position for listing restaurantaddresses.
  **/
  cursor?: restaurantaddressWhereUniqueInput
  /**
   * The number of restaurantaddresses to fetch. If negative number, it will take restaurantaddresses before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` restaurantaddresses.
  **/
  skip?: number
  distinct?: Enumerable<RestaurantaddressDistinctFieldEnum>
}


/**
 * restaurantaddress create
 */
export type restaurantaddressCreateArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
  /**
   * The data needed to create a restaurantaddress.
  **/
  data: restaurantaddressCreateInput
}


/**
 * restaurantaddress update
 */
export type restaurantaddressUpdateArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
  /**
   * The data needed to update a restaurantaddress.
  **/
  data: restaurantaddressUpdateInput
  /**
   * Choose, which restaurantaddress to update.
  **/
  where: restaurantaddressWhereUniqueInput
}


/**
 * restaurantaddress updateMany
 */
export type restaurantaddressUpdateManyArgs = {
  data: restaurantaddressUpdateManyMutationInput
  where?: restaurantaddressWhereInput
}


/**
 * restaurantaddress upsert
 */
export type restaurantaddressUpsertArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
  /**
   * The filter to search for the restaurantaddress to update in case it exists.
  **/
  where: restaurantaddressWhereUniqueInput
  /**
   * In case the restaurantaddress found by the `where` argument doesn't exist, create a new restaurantaddress with this data.
  **/
  create: restaurantaddressCreateInput
  /**
   * In case the restaurantaddress was found with the provided `where` argument, update it with this data.
  **/
  update: restaurantaddressUpdateInput
}


/**
 * restaurantaddress delete
 */
export type restaurantaddressDeleteArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
  /**
   * Filter which restaurantaddress to delete.
  **/
  where: restaurantaddressWhereUniqueInput
}


/**
 * restaurantaddress deleteMany
 */
export type restaurantaddressDeleteManyArgs = {
  where?: restaurantaddressWhereInput
}


/**
 * restaurantaddress without action
 */
export type restaurantaddressArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
}



/**
 * Model review
 */

export type review = {
  id: number
  title: string
  description: string
  rating: number | null
  client_id: number | null
  restaurant_id: number
}


export type AggregateReview = {
  count: number
  avg: ReviewAvgAggregateOutputType | null
  sum: ReviewSumAggregateOutputType | null
  min: ReviewMinAggregateOutputType | null
  max: ReviewMaxAggregateOutputType | null
}

export type ReviewAvgAggregateOutputType = {
  id: number
  rating: number
  client_id: number
  restaurant_id: number
}

export type ReviewSumAggregateOutputType = {
  id: number
  rating: number | null
  client_id: number | null
  restaurant_id: number
}

export type ReviewMinAggregateOutputType = {
  id: number
  rating: number | null
  client_id: number | null
  restaurant_id: number
}

export type ReviewMaxAggregateOutputType = {
  id: number
  rating: number | null
  client_id: number | null
  restaurant_id: number
}


export type ReviewAvgAggregateInputType = {
  id?: true
  rating?: true
  client_id?: true
  restaurant_id?: true
}

export type ReviewSumAggregateInputType = {
  id?: true
  rating?: true
  client_id?: true
  restaurant_id?: true
}

export type ReviewMinAggregateInputType = {
  id?: true
  rating?: true
  client_id?: true
  restaurant_id?: true
}

export type ReviewMaxAggregateInputType = {
  id?: true
  rating?: true
  client_id?: true
  restaurant_id?: true
}

export type AggregateReviewArgs = {
  where?: reviewWhereInput
  orderBy?: Enumerable<reviewOrderByInput>
  cursor?: reviewWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ReviewDistinctFieldEnum>
  count?: true
  avg?: ReviewAvgAggregateInputType
  sum?: ReviewSumAggregateInputType
  min?: ReviewMinAggregateInputType
  max?: ReviewMaxAggregateInputType
}

export type GetReviewAggregateType<T extends AggregateReviewArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetReviewAggregateScalarType<T[P]>
}

export type GetReviewAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ReviewAvgAggregateOutputType ? ReviewAvgAggregateOutputType[P] : never
}
    
    

export type reviewSelect = {
  id?: boolean
  title?: boolean
  description?: boolean
  rating?: boolean
  client_id?: boolean
  restaurant_id?: boolean
  client?: boolean | clientArgs
  restaurant?: boolean | restaurantArgs
}

export type reviewInclude = {
  client?: boolean | clientArgs
  restaurant?: boolean | restaurantArgs
}

export type reviewGetPayload<
  S extends boolean | null | undefined | reviewArgs,
  U = keyof S
> = S extends true
  ? review
  : S extends undefined
  ? never
  : S extends reviewArgs | FindManyreviewArgs
  ? 'include' extends U
    ? review  & {
      [P in TrueKeys<S['include']>]:
      P extends 'client'
      ? clientGetPayload<S['include'][P]> | null :
      P extends 'restaurant'
      ? restaurantGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof review ? review[P]
: 
      P extends 'client'
      ? clientGetPayload<S['select'][P]> | null :
      P extends 'restaurant'
      ? restaurantGetPayload<S['select'][P]> : never
    }
  : review
: review


export interface reviewDelegate {
  /**
   * Find zero or one Review.
   * @param {FindOnereviewArgs} args - Arguments to find a Review
   * @example
   * // Get one Review
   * const review = await prisma.review.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnereviewArgs>(
    args: Subset<T, FindOnereviewArgs>
  ): CheckSelect<T, Prisma__reviewClient<review | null>, Prisma__reviewClient<reviewGetPayload<T> | null>>
  /**
   * Find zero or more Reviews.
   * @param {FindManyreviewArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Reviews
   * const reviews = await prisma.review.findMany()
   * 
   * // Get first 10 Reviews
   * const reviews = await prisma.review.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyreviewArgs>(
    args?: Subset<T, FindManyreviewArgs>
  ): CheckSelect<T, Promise<Array<review>>, Promise<Array<reviewGetPayload<T>>>>
  /**
   * Create a Review.
   * @param {reviewCreateArgs} args - Arguments to create a Review.
   * @example
   * // Create one Review
   * const Review = await prisma.review.create({
   *   data: {
   *     // ... data to create a Review
   *   }
   * })
   * 
  **/
  create<T extends reviewCreateArgs>(
    args: Subset<T, reviewCreateArgs>
  ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>
  /**
   * Delete a Review.
   * @param {reviewDeleteArgs} args - Arguments to delete one Review.
   * @example
   * // Delete one Review
   * const Review = await prisma.review.delete({
   *   where: {
   *     // ... filter to delete one Review
   *   }
   * })
   * 
  **/
  delete<T extends reviewDeleteArgs>(
    args: Subset<T, reviewDeleteArgs>
  ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>
  /**
   * Update one Review.
   * @param {reviewUpdateArgs} args - Arguments to update one Review.
   * @example
   * // Update one Review
   * const review = await prisma.review.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends reviewUpdateArgs>(
    args: Subset<T, reviewUpdateArgs>
  ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>
  /**
   * Delete zero or more Reviews.
   * @param {reviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
   * @example
   * // Delete a few Reviews
   * const { count } = await prisma.review.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends reviewDeleteManyArgs>(
    args: Subset<T, reviewDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Reviews.
   * @param {reviewUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Reviews
   * const review = await prisma.review.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends reviewUpdateManyArgs>(
    args: Subset<T, reviewUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Review.
   * @param {reviewUpsertArgs} args - Arguments to update or create a Review.
   * @example
   * // Update or create a Review
   * const review = await prisma.review.upsert({
   *   create: {
   *     // ... data to create a Review
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Review we want to update
   *   }
   * })
  **/
  upsert<T extends reviewUpsertArgs>(
    args: Subset<T, reviewUpsertArgs>
  ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyreviewArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateReviewArgs>(args: Subset<T, AggregateReviewArgs>): Promise<GetReviewAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for review.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__reviewClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  client<T extends clientArgs = {}>(args?: Subset<T, clientArgs>): CheckSelect<T, Prisma__clientClient<client | null>, Prisma__clientClient<clientGetPayload<T> | null>>;

  restaurant<T extends restaurantArgs = {}>(args?: Subset<T, restaurantArgs>): CheckSelect<T, Prisma__restaurantClient<restaurant | null>, Prisma__restaurantClient<restaurantGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * review findOne
 */
export type FindOnereviewArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * Filter, which review to fetch.
  **/
  where: reviewWhereUniqueInput
}


/**
 * review findMany
 */
export type FindManyreviewArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * Filter, which reviews to fetch.
  **/
  where?: reviewWhereInput
  /**
   * Determine the order of the reviews to fetch.
  **/
  orderBy?: Enumerable<reviewOrderByInput>
  /**
   * Sets the position for listing reviews.
  **/
  cursor?: reviewWhereUniqueInput
  /**
   * The number of reviews to fetch. If negative number, it will take reviews before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` reviews.
  **/
  skip?: number
  distinct?: Enumerable<ReviewDistinctFieldEnum>
}


/**
 * review create
 */
export type reviewCreateArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * The data needed to create a review.
  **/
  data: reviewCreateInput
}


/**
 * review update
 */
export type reviewUpdateArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * The data needed to update a review.
  **/
  data: reviewUpdateInput
  /**
   * Choose, which review to update.
  **/
  where: reviewWhereUniqueInput
}


/**
 * review updateMany
 */
export type reviewUpdateManyArgs = {
  data: reviewUpdateManyMutationInput
  where?: reviewWhereInput
}


/**
 * review upsert
 */
export type reviewUpsertArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * The filter to search for the review to update in case it exists.
  **/
  where: reviewWhereUniqueInput
  /**
   * In case the review found by the `where` argument doesn't exist, create a new review with this data.
  **/
  create: reviewCreateInput
  /**
   * In case the review was found with the provided `where` argument, update it with this data.
  **/
  update: reviewUpdateInput
}


/**
 * review delete
 */
export type reviewDeleteArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * Filter which review to delete.
  **/
  where: reviewWhereUniqueInput
}


/**
 * review deleteMany
 */
export type reviewDeleteManyArgs = {
  where?: reviewWhereInput
}


/**
 * review without action
 */
export type reviewArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
}



/**
 * Deep Input Types
 */


export type NestedIntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: NestedIntFilter | null
}

export type IntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntFilter
}

export type NestedStringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: NestedStringFilter | null
}

export type StringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringFilter
}

export type NestedIntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
  not?: NestedIntNullableFilter | null
}

export type IntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
  not?: number | NestedIntNullableFilter | null
}

export type NestedStringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
  not?: NestedStringNullableFilter | null
}

export type StringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
  not?: string | NestedStringNullableFilter | null
}

export type AddressListRelationFilter = {
  every?: addressWhereInput
  some?: addressWhereInput
  none?: addressWhereInput
}

export type owneraccountWhereInput = {
  AND?: Enumerable<owneraccountWhereInput>
  OR?: Array<owneraccountWhereInput>
  NOT?: Enumerable<owneraccountWhereInput>
  id?: number | IntFilter
  client_id?: number | IntNullableFilter | null
  client?: clientWhereInput | null
}

export type OwneraccountListRelationFilter = {
  every?: owneraccountWhereInput
  some?: owneraccountWhereInput
  none?: owneraccountWhereInput
}

export type restaurantaddressWhereInput = {
  AND?: Enumerable<restaurantaddressWhereInput>
  OR?: Array<restaurantaddressWhereInput>
  NOT?: Enumerable<restaurantaddressWhereInput>
  id?: number | IntFilter
  city?: string | StringFilter
  street?: string | StringFilter
  zip?: string | StringFilter
  restaurant?: RestaurantListRelationFilter
}

export type RestaurantaddressRelationFilter = {
  is?: restaurantaddressWhereInput | null
  isNot?: restaurantaddressWhereInput | null
}

export type StringNullableListFilter = {
  equals?: Enumerable<string>
}

export type NestedFloatFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: NestedFloatFilter | null
}

export type FloatFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatFilter
}

export type RestaurantRelationFilter = {
  is?: restaurantWhereInput | null
  isNot?: restaurantWhereInput | null
}

export type dishWhereInput = {
  AND?: Enumerable<dishWhereInput>
  OR?: Array<dishWhereInput>
  NOT?: Enumerable<dishWhereInput>
  id?: number | IntFilter
  name?: string | StringFilter
  sizes?: Enumerable<string | StringNullableListFilter>
  ingredients?: Enumerable<string | StringNullableListFilter>
  price?: number | FloatFilter
  restaurant_id?: number | IntFilter
  restaurant?: restaurantWhereInput | null
}

export type DishListRelationFilter = {
  every?: dishWhereInput
  some?: dishWhereInput
  none?: dishWhereInput
}

export type reviewWhereInput = {
  AND?: Enumerable<reviewWhereInput>
  OR?: Array<reviewWhereInput>
  NOT?: Enumerable<reviewWhereInput>
  id?: number | IntFilter
  title?: string | StringFilter
  description?: string | StringFilter
  rating?: number | IntNullableFilter | null
  client_id?: number | IntNullableFilter | null
  restaurant_id?: number | IntFilter
  client?: clientWhereInput | null
  restaurant?: restaurantWhereInput | null
}

export type ReviewListRelationFilter = {
  every?: reviewWhereInput
  some?: reviewWhereInput
  none?: reviewWhereInput
}

export type restaurantWhereInput = {
  AND?: Enumerable<restaurantWhereInput>
  OR?: Array<restaurantWhereInput>
  NOT?: Enumerable<restaurantWhereInput>
  id?: number | IntFilter
  name?: string | StringFilter
  type?: string | StringFilter
  phone?: string | StringFilter
  delivery?: number | IntFilter
  deliveryfee?: number | IntFilter
  owner_id?: number | IntFilter
  address_id?: number | IntFilter
  restaurantaddress?: restaurantaddressWhereInput | null
  client?: clientWhereInput | null
  dish?: DishListRelationFilter
  review?: ReviewListRelationFilter
}

export type RestaurantListRelationFilter = {
  every?: restaurantWhereInput
  some?: restaurantWhereInput
  none?: restaurantWhereInput
}

export type clientWhereInput = {
  AND?: Enumerable<clientWhereInput>
  OR?: Array<clientWhereInput>
  NOT?: Enumerable<clientWhereInput>
  id?: number | IntFilter
  firstname?: string | StringFilter
  lastname?: string | StringFilter
  password?: string | StringFilter
  email?: string | StringFilter
  role?: string | StringNullableFilter | null
  address?: AddressListRelationFilter
  owneraccount?: OwneraccountListRelationFilter
  restaurant?: RestaurantListRelationFilter
  review?: ReviewListRelationFilter
}

export type ClientRelationFilter = {
  is?: clientWhereInput | null
  isNot?: clientWhereInput | null
}

export type addressWhereInput = {
  AND?: Enumerable<addressWhereInput>
  OR?: Array<addressWhereInput>
  NOT?: Enumerable<addressWhereInput>
  id?: number | IntFilter
  city?: string | StringFilter
  street?: string | StringFilter
  zip?: string | StringFilter
  client_id?: number | IntNullableFilter | null
  client?: clientWhereInput | null
}

export type addressOrderByInput = {
  id?: SortOrder
  city?: SortOrder
  street?: SortOrder
  zip?: SortOrder
  client_id?: SortOrder
}

export type addressWhereUniqueInput = {
  id?: number
}

export type owneraccountOrderByInput = {
  id?: SortOrder
  client_id?: SortOrder
}

export type owneraccountWhereUniqueInput = {
  id?: number
}

export type restaurantOrderByInput = {
  id?: SortOrder
  name?: SortOrder
  type?: SortOrder
  phone?: SortOrder
  delivery?: SortOrder
  deliveryfee?: SortOrder
  owner_id?: SortOrder
  address_id?: SortOrder
}

export type restaurantWhereUniqueInput = {
  id?: number
}

export type dishOrderByInput = {
  id?: SortOrder
  name?: SortOrder
  sizes?: SortOrder
  ingredients?: SortOrder
  price?: SortOrder
  restaurant_id?: SortOrder
}

export type dishWhereUniqueInput = {
  id?: number
}

export type reviewOrderByInput = {
  id?: SortOrder
  title?: SortOrder
  description?: SortOrder
  rating?: SortOrder
  client_id?: SortOrder
  restaurant_id?: SortOrder
}

export type reviewWhereUniqueInput = {
  id?: number
}

export type clientOrderByInput = {
  id?: SortOrder
  firstname?: SortOrder
  lastname?: SortOrder
  password?: SortOrder
  email?: SortOrder
  role?: SortOrder
}

export type clientWhereUniqueInput = {
  id?: number
  email?: string
}

export type restaurantaddressOrderByInput = {
  id?: SortOrder
  city?: SortOrder
  street?: SortOrder
  zip?: SortOrder
}

export type restaurantaddressWhereUniqueInput = {
  id?: number
}

export type owneraccountCreateWithoutClientInput = {

}

export type owneraccountCreateManyWithoutClientInput = {
  create?: Enumerable<owneraccountCreateWithoutClientInput>
  connect?: Enumerable<owneraccountWhereUniqueInput>
}

export type restaurantaddressCreateWithoutRestaurantInput = {
  city: string
  street: string
  zip: string
}

export type restaurantaddressCreateOneWithoutRestaurantInput = {
  create?: restaurantaddressCreateWithoutRestaurantInput
  connect?: restaurantaddressWhereUniqueInput
}

export type dishCreatesizesInput = {
  set?: Enumerable<string>
}

export type dishCreateingredientsInput = {
  set?: Enumerable<string>
}

export type dishCreateWithoutRestaurantInput = {
  name: string
  price: number
  sizes?: dishCreatesizesInput
  ingredients?: dishCreateingredientsInput
}

export type dishCreateManyWithoutRestaurantInput = {
  create?: Enumerable<dishCreateWithoutRestaurantInput>
  connect?: Enumerable<dishWhereUniqueInput>
}

export type addressCreateWithoutClientInput = {
  city: string
  street: string
  zip: string
}

export type addressCreateManyWithoutClientInput = {
  create?: Enumerable<addressCreateWithoutClientInput>
  connect?: Enumerable<addressWhereUniqueInput>
}

export type clientCreateWithoutReviewInput = {
  firstname: string
  lastname: string
  password: string
  email: string
  role?: string | null
  address?: addressCreateManyWithoutClientInput
  owneraccount?: owneraccountCreateManyWithoutClientInput
  restaurant?: restaurantCreateManyWithoutClientInput
}

export type clientCreateOneWithoutReviewInput = {
  create?: clientCreateWithoutReviewInput
  connect?: clientWhereUniqueInput
}

export type reviewCreateWithoutRestaurantInput = {
  title: string
  description: string
  rating?: number | null
  client?: clientCreateOneWithoutReviewInput
}

export type reviewCreateManyWithoutRestaurantInput = {
  create?: Enumerable<reviewCreateWithoutRestaurantInput>
  connect?: Enumerable<reviewWhereUniqueInput>
}

export type restaurantCreateWithoutClientInput = {
  name: string
  type: string
  phone: string
  delivery: number
  deliveryfee: number
  restaurantaddress: restaurantaddressCreateOneWithoutRestaurantInput
  dish?: dishCreateManyWithoutRestaurantInput
  review?: reviewCreateManyWithoutRestaurantInput
}

export type restaurantCreateManyWithoutClientInput = {
  create?: Enumerable<restaurantCreateWithoutClientInput>
  connect?: Enumerable<restaurantWhereUniqueInput>
}

export type clientCreateWithoutRestaurantInput = {
  firstname: string
  lastname: string
  password: string
  email: string
  role?: string | null
  address?: addressCreateManyWithoutClientInput
  owneraccount?: owneraccountCreateManyWithoutClientInput
  review?: reviewCreateManyWithoutClientInput
}

export type clientCreateOneWithoutRestaurantInput = {
  create?: clientCreateWithoutRestaurantInput
  connect?: clientWhereUniqueInput
}

export type restaurantCreateWithoutReviewInput = {
  name: string
  type: string
  phone: string
  delivery: number
  deliveryfee: number
  restaurantaddress: restaurantaddressCreateOneWithoutRestaurantInput
  client: clientCreateOneWithoutRestaurantInput
  dish?: dishCreateManyWithoutRestaurantInput
}

export type restaurantCreateOneWithoutReviewInput = {
  create?: restaurantCreateWithoutReviewInput
  connect?: restaurantWhereUniqueInput
}

export type reviewCreateWithoutClientInput = {
  title: string
  description: string
  rating?: number | null
  restaurant: restaurantCreateOneWithoutReviewInput
}

export type reviewCreateManyWithoutClientInput = {
  create?: Enumerable<reviewCreateWithoutClientInput>
  connect?: Enumerable<reviewWhereUniqueInput>
}

export type clientCreateWithoutAddressInput = {
  firstname: string
  lastname: string
  password: string
  email: string
  role?: string | null
  owneraccount?: owneraccountCreateManyWithoutClientInput
  restaurant?: restaurantCreateManyWithoutClientInput
  review?: reviewCreateManyWithoutClientInput
}

export type clientCreateOneWithoutAddressInput = {
  create?: clientCreateWithoutAddressInput
  connect?: clientWhereUniqueInput
}

export type addressCreateInput = {
  city: string
  street: string
  zip: string
  client?: clientCreateOneWithoutAddressInput
}

export type owneraccountUpdateWithoutClientDataInput = {

}

export type owneraccountUpdateWithWhereUniqueWithoutClientInput = {
  where: owneraccountWhereUniqueInput
  data: owneraccountUpdateWithoutClientDataInput
}

export type owneraccountScalarWhereInput = {
  AND?: Enumerable<owneraccountScalarWhereInput>
  OR?: Array<owneraccountScalarWhereInput>
  NOT?: Enumerable<owneraccountScalarWhereInput>
  id?: number | IntFilter
  client_id?: number | IntNullableFilter | null
}

export type owneraccountUpdateManyDataInput = {

}

export type owneraccountUpdateManyWithWhereNestedInput = {
  where: owneraccountScalarWhereInput
  data: owneraccountUpdateManyDataInput
}

export type owneraccountUpdateManyWithoutClientInput = {
  create?: Enumerable<owneraccountCreateWithoutClientInput>
  connect?: Enumerable<owneraccountWhereUniqueInput>
  set?: Enumerable<owneraccountWhereUniqueInput>
  disconnect?: Enumerable<owneraccountWhereUniqueInput>
  delete?: Enumerable<owneraccountWhereUniqueInput>
  update?: Enumerable<owneraccountUpdateWithWhereUniqueWithoutClientInput>
  updateMany?: Enumerable<owneraccountUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<owneraccountScalarWhereInput>
}

export type restaurantaddressUpdateWithoutRestaurantDataInput = {
  city?: string
  street?: string
  zip?: string
}

export type restaurantaddressUpsertWithoutRestaurantInput = {
  update: restaurantaddressUpdateWithoutRestaurantDataInput
  create: restaurantaddressCreateWithoutRestaurantInput
}

export type restaurantaddressUpdateOneRequiredWithoutRestaurantInput = {
  create?: restaurantaddressCreateWithoutRestaurantInput
  connect?: restaurantaddressWhereUniqueInput
  update?: restaurantaddressUpdateWithoutRestaurantDataInput
  upsert?: restaurantaddressUpsertWithoutRestaurantInput
}

export type dishUpdatesizesInput = {
  set?: Enumerable<string>
}

export type dishUpdateingredientsInput = {
  set?: Enumerable<string>
}

export type dishUpdateWithoutRestaurantDataInput = {
  name?: string
  price?: number
  sizes?: dishUpdatesizesInput
  ingredients?: dishUpdateingredientsInput
}

export type dishUpdateWithWhereUniqueWithoutRestaurantInput = {
  where: dishWhereUniqueInput
  data: dishUpdateWithoutRestaurantDataInput
}

export type dishScalarWhereInput = {
  AND?: Enumerable<dishScalarWhereInput>
  OR?: Array<dishScalarWhereInput>
  NOT?: Enumerable<dishScalarWhereInput>
  id?: number | IntFilter
  name?: string | StringFilter
  sizes?: Enumerable<string | StringNullableListFilter>
  ingredients?: Enumerable<string | StringNullableListFilter>
  price?: number | FloatFilter
  restaurant_id?: number | IntFilter
}

export type dishUpdateManyDataInput = {
  name?: string
  price?: number
  sizes?: dishUpdatesizesInput
  ingredients?: dishUpdateingredientsInput
}

export type dishUpdateManyWithWhereNestedInput = {
  where: dishScalarWhereInput
  data: dishUpdateManyDataInput
}

export type dishUpsertWithWhereUniqueWithoutRestaurantInput = {
  where: dishWhereUniqueInput
  update: dishUpdateWithoutRestaurantDataInput
  create: dishCreateWithoutRestaurantInput
}

export type dishUpdateManyWithoutRestaurantInput = {
  create?: Enumerable<dishCreateWithoutRestaurantInput>
  connect?: Enumerable<dishWhereUniqueInput>
  set?: Enumerable<dishWhereUniqueInput>
  disconnect?: Enumerable<dishWhereUniqueInput>
  delete?: Enumerable<dishWhereUniqueInput>
  update?: Enumerable<dishUpdateWithWhereUniqueWithoutRestaurantInput>
  updateMany?: Enumerable<dishUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<dishScalarWhereInput>
  upsert?: Enumerable<dishUpsertWithWhereUniqueWithoutRestaurantInput>
}

export type addressUpdateWithoutClientDataInput = {
  city?: string
  street?: string
  zip?: string
}

export type addressUpdateWithWhereUniqueWithoutClientInput = {
  where: addressWhereUniqueInput
  data: addressUpdateWithoutClientDataInput
}

export type addressScalarWhereInput = {
  AND?: Enumerable<addressScalarWhereInput>
  OR?: Array<addressScalarWhereInput>
  NOT?: Enumerable<addressScalarWhereInput>
  id?: number | IntFilter
  city?: string | StringFilter
  street?: string | StringFilter
  zip?: string | StringFilter
  client_id?: number | IntNullableFilter | null
}

export type addressUpdateManyDataInput = {
  city?: string
  street?: string
  zip?: string
}

export type addressUpdateManyWithWhereNestedInput = {
  where: addressScalarWhereInput
  data: addressUpdateManyDataInput
}

export type addressUpsertWithWhereUniqueWithoutClientInput = {
  where: addressWhereUniqueInput
  update: addressUpdateWithoutClientDataInput
  create: addressCreateWithoutClientInput
}

export type addressUpdateManyWithoutClientInput = {
  create?: Enumerable<addressCreateWithoutClientInput>
  connect?: Enumerable<addressWhereUniqueInput>
  set?: Enumerable<addressWhereUniqueInput>
  disconnect?: Enumerable<addressWhereUniqueInput>
  delete?: Enumerable<addressWhereUniqueInput>
  update?: Enumerable<addressUpdateWithWhereUniqueWithoutClientInput>
  updateMany?: Enumerable<addressUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<addressScalarWhereInput>
  upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutClientInput>
}

export type clientUpdateWithoutReviewDataInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
  address?: addressUpdateManyWithoutClientInput
  owneraccount?: owneraccountUpdateManyWithoutClientInput
  restaurant?: restaurantUpdateManyWithoutClientInput
}

export type clientUpsertWithoutReviewInput = {
  update: clientUpdateWithoutReviewDataInput
  create: clientCreateWithoutReviewInput
}

export type clientUpdateOneWithoutReviewInput = {
  create?: clientCreateWithoutReviewInput
  connect?: clientWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: clientUpdateWithoutReviewDataInput
  upsert?: clientUpsertWithoutReviewInput
}

export type reviewUpdateWithoutRestaurantDataInput = {
  title?: string
  description?: string
  rating?: number | null
  client?: clientUpdateOneWithoutReviewInput
}

export type reviewUpdateWithWhereUniqueWithoutRestaurantInput = {
  where: reviewWhereUniqueInput
  data: reviewUpdateWithoutRestaurantDataInput
}

export type reviewScalarWhereInput = {
  AND?: Enumerable<reviewScalarWhereInput>
  OR?: Array<reviewScalarWhereInput>
  NOT?: Enumerable<reviewScalarWhereInput>
  id?: number | IntFilter
  title?: string | StringFilter
  description?: string | StringFilter
  rating?: number | IntNullableFilter | null
  client_id?: number | IntNullableFilter | null
  restaurant_id?: number | IntFilter
}

export type reviewUpdateManyDataInput = {
  title?: string
  description?: string
  rating?: number | null
}

export type reviewUpdateManyWithWhereNestedInput = {
  where: reviewScalarWhereInput
  data: reviewUpdateManyDataInput
}

export type reviewUpsertWithWhereUniqueWithoutRestaurantInput = {
  where: reviewWhereUniqueInput
  update: reviewUpdateWithoutRestaurantDataInput
  create: reviewCreateWithoutRestaurantInput
}

export type reviewUpdateManyWithoutRestaurantInput = {
  create?: Enumerable<reviewCreateWithoutRestaurantInput>
  connect?: Enumerable<reviewWhereUniqueInput>
  set?: Enumerable<reviewWhereUniqueInput>
  disconnect?: Enumerable<reviewWhereUniqueInput>
  delete?: Enumerable<reviewWhereUniqueInput>
  update?: Enumerable<reviewUpdateWithWhereUniqueWithoutRestaurantInput>
  updateMany?: Enumerable<reviewUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<reviewScalarWhereInput>
  upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutRestaurantInput>
}

export type restaurantUpdateWithoutClientDataInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
  restaurantaddress?: restaurantaddressUpdateOneRequiredWithoutRestaurantInput
  dish?: dishUpdateManyWithoutRestaurantInput
  review?: reviewUpdateManyWithoutRestaurantInput
}

export type restaurantUpdateWithWhereUniqueWithoutClientInput = {
  where: restaurantWhereUniqueInput
  data: restaurantUpdateWithoutClientDataInput
}

export type restaurantScalarWhereInput = {
  AND?: Enumerable<restaurantScalarWhereInput>
  OR?: Array<restaurantScalarWhereInput>
  NOT?: Enumerable<restaurantScalarWhereInput>
  id?: number | IntFilter
  name?: string | StringFilter
  type?: string | StringFilter
  phone?: string | StringFilter
  delivery?: number | IntFilter
  deliveryfee?: number | IntFilter
  owner_id?: number | IntFilter
  address_id?: number | IntFilter
}

export type restaurantUpdateManyDataInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
}

export type restaurantUpdateManyWithWhereNestedInput = {
  where: restaurantScalarWhereInput
  data: restaurantUpdateManyDataInput
}

export type restaurantUpsertWithWhereUniqueWithoutClientInput = {
  where: restaurantWhereUniqueInput
  update: restaurantUpdateWithoutClientDataInput
  create: restaurantCreateWithoutClientInput
}

export type restaurantUpdateManyWithoutClientInput = {
  create?: Enumerable<restaurantCreateWithoutClientInput>
  connect?: Enumerable<restaurantWhereUniqueInput>
  set?: Enumerable<restaurantWhereUniqueInput>
  disconnect?: Enumerable<restaurantWhereUniqueInput>
  delete?: Enumerable<restaurantWhereUniqueInput>
  update?: Enumerable<restaurantUpdateWithWhereUniqueWithoutClientInput>
  updateMany?: Enumerable<restaurantUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<restaurantScalarWhereInput>
  upsert?: Enumerable<restaurantUpsertWithWhereUniqueWithoutClientInput>
}

export type clientUpdateWithoutRestaurantDataInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
  address?: addressUpdateManyWithoutClientInput
  owneraccount?: owneraccountUpdateManyWithoutClientInput
  review?: reviewUpdateManyWithoutClientInput
}

export type clientUpsertWithoutRestaurantInput = {
  update: clientUpdateWithoutRestaurantDataInput
  create: clientCreateWithoutRestaurantInput
}

export type clientUpdateOneRequiredWithoutRestaurantInput = {
  create?: clientCreateWithoutRestaurantInput
  connect?: clientWhereUniqueInput
  update?: clientUpdateWithoutRestaurantDataInput
  upsert?: clientUpsertWithoutRestaurantInput
}

export type restaurantUpdateWithoutReviewDataInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
  restaurantaddress?: restaurantaddressUpdateOneRequiredWithoutRestaurantInput
  client?: clientUpdateOneRequiredWithoutRestaurantInput
  dish?: dishUpdateManyWithoutRestaurantInput
}

export type restaurantUpsertWithoutReviewInput = {
  update: restaurantUpdateWithoutReviewDataInput
  create: restaurantCreateWithoutReviewInput
}

export type restaurantUpdateOneRequiredWithoutReviewInput = {
  create?: restaurantCreateWithoutReviewInput
  connect?: restaurantWhereUniqueInput
  update?: restaurantUpdateWithoutReviewDataInput
  upsert?: restaurantUpsertWithoutReviewInput
}

export type reviewUpdateWithoutClientDataInput = {
  title?: string
  description?: string
  rating?: number | null
  restaurant?: restaurantUpdateOneRequiredWithoutReviewInput
}

export type reviewUpdateWithWhereUniqueWithoutClientInput = {
  where: reviewWhereUniqueInput
  data: reviewUpdateWithoutClientDataInput
}

export type reviewUpsertWithWhereUniqueWithoutClientInput = {
  where: reviewWhereUniqueInput
  update: reviewUpdateWithoutClientDataInput
  create: reviewCreateWithoutClientInput
}

export type reviewUpdateManyWithoutClientInput = {
  create?: Enumerable<reviewCreateWithoutClientInput>
  connect?: Enumerable<reviewWhereUniqueInput>
  set?: Enumerable<reviewWhereUniqueInput>
  disconnect?: Enumerable<reviewWhereUniqueInput>
  delete?: Enumerable<reviewWhereUniqueInput>
  update?: Enumerable<reviewUpdateWithWhereUniqueWithoutClientInput>
  updateMany?: Enumerable<reviewUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<reviewScalarWhereInput>
  upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutClientInput>
}

export type clientUpdateWithoutAddressDataInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
  owneraccount?: owneraccountUpdateManyWithoutClientInput
  restaurant?: restaurantUpdateManyWithoutClientInput
  review?: reviewUpdateManyWithoutClientInput
}

export type clientUpsertWithoutAddressInput = {
  update: clientUpdateWithoutAddressDataInput
  create: clientCreateWithoutAddressInput
}

export type clientUpdateOneWithoutAddressInput = {
  create?: clientCreateWithoutAddressInput
  connect?: clientWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: clientUpdateWithoutAddressDataInput
  upsert?: clientUpsertWithoutAddressInput
}

export type addressUpdateInput = {
  city?: string
  street?: string
  zip?: string
  client?: clientUpdateOneWithoutAddressInput
}

export type addressUpdateManyMutationInput = {
  city?: string
  street?: string
  zip?: string
}

export type clientCreateInput = {
  firstname: string
  lastname: string
  password: string
  email: string
  role?: string | null
  address?: addressCreateManyWithoutClientInput
  owneraccount?: owneraccountCreateManyWithoutClientInput
  restaurant?: restaurantCreateManyWithoutClientInput
  review?: reviewCreateManyWithoutClientInput
}

export type clientUpdateInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
  address?: addressUpdateManyWithoutClientInput
  owneraccount?: owneraccountUpdateManyWithoutClientInput
  restaurant?: restaurantUpdateManyWithoutClientInput
  review?: reviewUpdateManyWithoutClientInput
}

export type clientUpdateManyMutationInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
}

export type restaurantCreateWithoutDishInput = {
  name: string
  type: string
  phone: string
  delivery: number
  deliveryfee: number
  restaurantaddress: restaurantaddressCreateOneWithoutRestaurantInput
  client: clientCreateOneWithoutRestaurantInput
  review?: reviewCreateManyWithoutRestaurantInput
}

export type restaurantCreateOneWithoutDishInput = {
  create?: restaurantCreateWithoutDishInput
  connect?: restaurantWhereUniqueInput
}

export type dishCreateInput = {
  name: string
  price: number
  sizes?: dishCreatesizesInput
  ingredients?: dishCreateingredientsInput
  restaurant: restaurantCreateOneWithoutDishInput
}

export type restaurantUpdateWithoutDishDataInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
  restaurantaddress?: restaurantaddressUpdateOneRequiredWithoutRestaurantInput
  client?: clientUpdateOneRequiredWithoutRestaurantInput
  review?: reviewUpdateManyWithoutRestaurantInput
}

export type restaurantUpsertWithoutDishInput = {
  update: restaurantUpdateWithoutDishDataInput
  create: restaurantCreateWithoutDishInput
}

export type restaurantUpdateOneRequiredWithoutDishInput = {
  create?: restaurantCreateWithoutDishInput
  connect?: restaurantWhereUniqueInput
  update?: restaurantUpdateWithoutDishDataInput
  upsert?: restaurantUpsertWithoutDishInput
}

export type dishUpdateInput = {
  name?: string
  price?: number
  sizes?: dishUpdatesizesInput
  ingredients?: dishUpdateingredientsInput
  restaurant?: restaurantUpdateOneRequiredWithoutDishInput
}

export type dishUpdateManyMutationInput = {
  name?: string
  price?: number
  sizes?: dishUpdatesizesInput
  ingredients?: dishUpdateingredientsInput
}

export type clientCreateWithoutOwneraccountInput = {
  firstname: string
  lastname: string
  password: string
  email: string
  role?: string | null
  address?: addressCreateManyWithoutClientInput
  restaurant?: restaurantCreateManyWithoutClientInput
  review?: reviewCreateManyWithoutClientInput
}

export type clientCreateOneWithoutOwneraccountInput = {
  create?: clientCreateWithoutOwneraccountInput
  connect?: clientWhereUniqueInput
}

export type owneraccountCreateInput = {
  client?: clientCreateOneWithoutOwneraccountInput
}

export type clientUpdateWithoutOwneraccountDataInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
  address?: addressUpdateManyWithoutClientInput
  restaurant?: restaurantUpdateManyWithoutClientInput
  review?: reviewUpdateManyWithoutClientInput
}

export type clientUpsertWithoutOwneraccountInput = {
  update: clientUpdateWithoutOwneraccountDataInput
  create: clientCreateWithoutOwneraccountInput
}

export type clientUpdateOneWithoutOwneraccountInput = {
  create?: clientCreateWithoutOwneraccountInput
  connect?: clientWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: clientUpdateWithoutOwneraccountDataInput
  upsert?: clientUpsertWithoutOwneraccountInput
}

export type owneraccountUpdateInput = {
  client?: clientUpdateOneWithoutOwneraccountInput
}

export type owneraccountUpdateManyMutationInput = {

}

export type restaurantCreateInput = {
  name: string
  type: string
  phone: string
  delivery: number
  deliveryfee: number
  restaurantaddress: restaurantaddressCreateOneWithoutRestaurantInput
  client: clientCreateOneWithoutRestaurantInput
  dish?: dishCreateManyWithoutRestaurantInput
  review?: reviewCreateManyWithoutRestaurantInput
}

export type restaurantUpdateInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
  restaurantaddress?: restaurantaddressUpdateOneRequiredWithoutRestaurantInput
  client?: clientUpdateOneRequiredWithoutRestaurantInput
  dish?: dishUpdateManyWithoutRestaurantInput
  review?: reviewUpdateManyWithoutRestaurantInput
}

export type restaurantUpdateManyMutationInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
}

export type restaurantCreateWithoutRestaurantaddressInput = {
  name: string
  type: string
  phone: string
  delivery: number
  deliveryfee: number
  client: clientCreateOneWithoutRestaurantInput
  dish?: dishCreateManyWithoutRestaurantInput
  review?: reviewCreateManyWithoutRestaurantInput
}

export type restaurantCreateManyWithoutRestaurantaddressInput = {
  create?: Enumerable<restaurantCreateWithoutRestaurantaddressInput>
  connect?: Enumerable<restaurantWhereUniqueInput>
}

export type restaurantaddressCreateInput = {
  city: string
  street: string
  zip: string
  restaurant?: restaurantCreateManyWithoutRestaurantaddressInput
}

export type restaurantUpdateWithoutRestaurantaddressDataInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
  client?: clientUpdateOneRequiredWithoutRestaurantInput
  dish?: dishUpdateManyWithoutRestaurantInput
  review?: reviewUpdateManyWithoutRestaurantInput
}

export type restaurantUpdateWithWhereUniqueWithoutRestaurantaddressInput = {
  where: restaurantWhereUniqueInput
  data: restaurantUpdateWithoutRestaurantaddressDataInput
}

export type restaurantUpsertWithWhereUniqueWithoutRestaurantaddressInput = {
  where: restaurantWhereUniqueInput
  update: restaurantUpdateWithoutRestaurantaddressDataInput
  create: restaurantCreateWithoutRestaurantaddressInput
}

export type restaurantUpdateManyWithoutRestaurantaddressInput = {
  create?: Enumerable<restaurantCreateWithoutRestaurantaddressInput>
  connect?: Enumerable<restaurantWhereUniqueInput>
  set?: Enumerable<restaurantWhereUniqueInput>
  disconnect?: Enumerable<restaurantWhereUniqueInput>
  delete?: Enumerable<restaurantWhereUniqueInput>
  update?: Enumerable<restaurantUpdateWithWhereUniqueWithoutRestaurantaddressInput>
  updateMany?: Enumerable<restaurantUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<restaurantScalarWhereInput>
  upsert?: Enumerable<restaurantUpsertWithWhereUniqueWithoutRestaurantaddressInput>
}

export type restaurantaddressUpdateInput = {
  city?: string
  street?: string
  zip?: string
  restaurant?: restaurantUpdateManyWithoutRestaurantaddressInput
}

export type restaurantaddressUpdateManyMutationInput = {
  city?: string
  street?: string
  zip?: string
}

export type reviewCreateInput = {
  title: string
  description: string
  rating?: number | null
  client?: clientCreateOneWithoutReviewInput
  restaurant: restaurantCreateOneWithoutReviewInput
}

export type reviewUpdateInput = {
  title?: string
  description?: string
  rating?: number | null
  client?: clientUpdateOneWithoutReviewInput
  restaurant?: restaurantUpdateOneRequiredWithoutReviewInput
}

export type reviewUpdateManyMutationInput = {
  title?: string
  description?: string
  rating?: number | null
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
