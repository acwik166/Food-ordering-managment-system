import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw }

/**
 * Prisma Client JS version: 2.5.1
 * Query Engine version: c88925ce44a9b89b4351aec85ba6a28979d2658e
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export declare type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export declare type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends Array<LogLevel | LogDefinition>> = GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]> 

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type Action =
  | 'findOne'
  | 'findMany'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: Action
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Addresses
 * const addresses = await prisma.address.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = keyof T extends 'log' ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Addresses
   * const addresses = await prisma.address.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */
  constructor(optionsArg?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * @deprecated renamed to `$on`
   */
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  $connect(): Promise<void>;
  /**
   * @deprecated renamed to `$connect`
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;
  /**
   * @deprecated renamed to `$disconnect`
   */
  disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * @deprecated renamed to `$executeRaw`
   */
  executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;
 
  /**
   * @deprecated renamed to `$executeRaw`
   */
  queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): addressDelegate;

  /**
   * `prisma.dish`: Exposes CRUD operations for the **dish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dishes
    * const dishes = await prisma.dish.findMany()
    * ```
    */
  get dish(): dishDelegate;

  /**
   * `prisma.order`: Exposes CRUD operations for the **order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): orderDelegate;

  /**
   * `prisma.orderitem`: Exposes CRUD operations for the **orderitem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orderitems
    * const orderitems = await prisma.orderitem.findMany()
    * ```
    */
  get orderitem(): orderitemDelegate;

  /**
   * `prisma.owneraccount`: Exposes CRUD operations for the **owneraccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owneraccounts
    * const owneraccounts = await prisma.owneraccount.findMany()
    * ```
    */
  get owneraccount(): owneraccountDelegate;

  /**
   * `prisma.restaurant`: Exposes CRUD operations for the **restaurant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restaurants
    * const restaurants = await prisma.restaurant.findMany()
    * ```
    */
  get restaurant(): restaurantDelegate;

  /**
   * `prisma.restaurantaddress`: Exposes CRUD operations for the **restaurantaddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Restaurantaddresses
    * const restaurantaddresses = await prisma.restaurantaddress.findMany()
    * ```
    */
  get restaurantaddress(): restaurantaddressDelegate;

  /**
   * `prisma.review`: Exposes CRUD operations for the **review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): reviewDelegate;

  /**
   * `prisma.status`: Exposes CRUD operations for the **status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statuses
    * const statuses = await prisma.status.findMany()
    * ```
    */
  get status(): statusDelegate;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): userDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const SortOrder: {
  asc: 'asc',
  desc: 'desc'
};

export declare type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export declare const AddressDistinctFieldEnum: {
  id: 'id',
  city: 'city',
  street: 'street',
  zip: 'zip',
  user_id: 'user_id'
};

export declare type AddressDistinctFieldEnum = (typeof AddressDistinctFieldEnum)[keyof typeof AddressDistinctFieldEnum]


export declare const OrderDistinctFieldEnum: {
  id: 'id',
  user_id: 'user_id',
  date: 'date',
  status_id: 'status_id',
  quantity: 'quantity',
  amount: 'amount',
  address_id: 'address_id',
  phone: 'phone'
};

export declare type OrderDistinctFieldEnum = (typeof OrderDistinctFieldEnum)[keyof typeof OrderDistinctFieldEnum]


export declare const OrderitemDistinctFieldEnum: {
  id: 'id',
  quantity: 'quantity',
  item_id: 'item_id',
  order_id: 'order_id'
};

export declare type OrderitemDistinctFieldEnum = (typeof OrderitemDistinctFieldEnum)[keyof typeof OrderitemDistinctFieldEnum]


export declare const RestaurantDistinctFieldEnum: {
  id: 'id',
  name: 'name',
  type: 'type',
  phone: 'phone',
  delivery: 'delivery',
  deliveryfee: 'deliveryfee',
  owner_id: 'owner_id',
  address_id: 'address_id'
};

export declare type RestaurantDistinctFieldEnum = (typeof RestaurantDistinctFieldEnum)[keyof typeof RestaurantDistinctFieldEnum]


export declare const DishDistinctFieldEnum: {
  id: 'id',
  name: 'name',
  sizes: 'sizes',
  ingredients: 'ingredients',
  price: 'price',
  restaurant_id: 'restaurant_id',
  ingredientchoice: 'ingredientchoice',
  additions: 'additions'
};

export declare type DishDistinctFieldEnum = (typeof DishDistinctFieldEnum)[keyof typeof DishDistinctFieldEnum]


export declare const ReviewDistinctFieldEnum: {
  id: 'id',
  title: 'title',
  description: 'description',
  rating: 'rating',
  user_id: 'user_id',
  restaurant_id: 'restaurant_id'
};

export declare type ReviewDistinctFieldEnum = (typeof ReviewDistinctFieldEnum)[keyof typeof ReviewDistinctFieldEnum]


export declare const OwneraccountDistinctFieldEnum: {
  id: 'id',
  client_id: 'client_id'
};

export declare type OwneraccountDistinctFieldEnum = (typeof OwneraccountDistinctFieldEnum)[keyof typeof OwneraccountDistinctFieldEnum]


export declare const RestaurantaddressDistinctFieldEnum: {
  id: 'id',
  city: 'city',
  street: 'street',
  zip: 'zip'
};

export declare type RestaurantaddressDistinctFieldEnum = (typeof RestaurantaddressDistinctFieldEnum)[keyof typeof RestaurantaddressDistinctFieldEnum]


export declare const StatusDistinctFieldEnum: {
  id: 'id',
  code: 'code',
  description: 'description'
};

export declare type StatusDistinctFieldEnum = (typeof StatusDistinctFieldEnum)[keyof typeof StatusDistinctFieldEnum]


export declare const UserDistinctFieldEnum: {
  id: 'id',
  firstname: 'firstname',
  lastname: 'lastname',
  password: 'password',
  email: 'email',
  role: 'role'
};

export declare type UserDistinctFieldEnum = (typeof UserDistinctFieldEnum)[keyof typeof UserDistinctFieldEnum]



/**
 * Model address
 */

export type address = {
  id: number
  city: string
  street: string
  zip: string
  user_id: number | null
}


export type AggregateAddress = {
  count: number
  avg: AddressAvgAggregateOutputType | null
  sum: AddressSumAggregateOutputType | null
  min: AddressMinAggregateOutputType | null
  max: AddressMaxAggregateOutputType | null
}

export type AddressAvgAggregateOutputType = {
  id: number
  user_id: number
}

export type AddressSumAggregateOutputType = {
  id: number
  user_id: number | null
}

export type AddressMinAggregateOutputType = {
  id: number
  user_id: number | null
}

export type AddressMaxAggregateOutputType = {
  id: number
  user_id: number | null
}


export type AddressAvgAggregateInputType = {
  id?: true
  user_id?: true
}

export type AddressSumAggregateInputType = {
  id?: true
  user_id?: true
}

export type AddressMinAggregateInputType = {
  id?: true
  user_id?: true
}

export type AddressMaxAggregateInputType = {
  id?: true
  user_id?: true
}

export type AggregateAddressArgs = {
  where?: addressWhereInput
  orderBy?: Enumerable<addressOrderByInput>
  cursor?: addressWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<AddressDistinctFieldEnum>
  count?: true
  avg?: AddressAvgAggregateInputType
  sum?: AddressSumAggregateInputType
  min?: AddressMinAggregateInputType
  max?: AddressMaxAggregateInputType
}

export type GetAddressAggregateType<T extends AggregateAddressArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetAddressAggregateScalarType<T[P]>
}

export type GetAddressAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof AddressAvgAggregateOutputType ? AddressAvgAggregateOutputType[P] : never
}
    
    

export type addressSelect = {
  id?: boolean
  city?: boolean
  street?: boolean
  zip?: boolean
  user_id?: boolean
  user?: boolean | userArgs
  order?: boolean | FindManyorderArgs
}

export type addressInclude = {
  user?: boolean | userArgs
  order?: boolean | FindManyorderArgs
}

export type addressGetPayload<
  S extends boolean | null | undefined | addressArgs,
  U = keyof S
> = S extends true
  ? address
  : S extends undefined
  ? never
  : S extends addressArgs | FindManyaddressArgs
  ? 'include' extends U
    ? address  & {
      [P in TrueKeys<S['include']>]:
      P extends 'user'
      ? userGetPayload<S['include'][P]> | null :
      P extends 'order'
      ? Array<orderGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof address ? address[P]
: 
      P extends 'user'
      ? userGetPayload<S['select'][P]> | null :
      P extends 'order'
      ? Array<orderGetPayload<S['select'][P]>> : never
    }
  : address
: address


export interface addressDelegate {
  /**
   * Find zero or one Address.
   * @param {FindOneaddressArgs} args - Arguments to find a Address
   * @example
   * // Get one Address
   * const address = await prisma.address.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneaddressArgs>(
    args: Subset<T, FindOneaddressArgs>
  ): CheckSelect<T, Prisma__addressClient<address | null>, Prisma__addressClient<addressGetPayload<T> | null>>
  /**
   * Find zero or more Addresses.
   * @param {FindManyaddressArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Addresses
   * const addresses = await prisma.address.findMany()
   * 
   * // Get first 10 Addresses
   * const addresses = await prisma.address.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyaddressArgs>(
    args?: Subset<T, FindManyaddressArgs>
  ): CheckSelect<T, Promise<Array<address>>, Promise<Array<addressGetPayload<T>>>>
  /**
   * Create a Address.
   * @param {addressCreateArgs} args - Arguments to create a Address.
   * @example
   * // Create one Address
   * const Address = await prisma.address.create({
   *   data: {
   *     // ... data to create a Address
   *   }
   * })
   * 
  **/
  create<T extends addressCreateArgs>(
    args: Subset<T, addressCreateArgs>
  ): CheckSelect<T, Prisma__addressClient<address>, Prisma__addressClient<addressGetPayload<T>>>
  /**
   * Delete a Address.
   * @param {addressDeleteArgs} args - Arguments to delete one Address.
   * @example
   * // Delete one Address
   * const Address = await prisma.address.delete({
   *   where: {
   *     // ... filter to delete one Address
   *   }
   * })
   * 
  **/
  delete<T extends addressDeleteArgs>(
    args: Subset<T, addressDeleteArgs>
  ): CheckSelect<T, Prisma__addressClient<address>, Prisma__addressClient<addressGetPayload<T>>>
  /**
   * Update one Address.
   * @param {addressUpdateArgs} args - Arguments to update one Address.
   * @example
   * // Update one Address
   * const address = await prisma.address.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends addressUpdateArgs>(
    args: Subset<T, addressUpdateArgs>
  ): CheckSelect<T, Prisma__addressClient<address>, Prisma__addressClient<addressGetPayload<T>>>
  /**
   * Delete zero or more Addresses.
   * @param {addressDeleteManyArgs} args - Arguments to filter Addresses to delete.
   * @example
   * // Delete a few Addresses
   * const { count } = await prisma.address.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends addressDeleteManyArgs>(
    args: Subset<T, addressDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Addresses.
   * @param {addressUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Addresses
   * const address = await prisma.address.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends addressUpdateManyArgs>(
    args: Subset<T, addressUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Address.
   * @param {addressUpsertArgs} args - Arguments to update or create a Address.
   * @example
   * // Update or create a Address
   * const address = await prisma.address.upsert({
   *   create: {
   *     // ... data to create a Address
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Address we want to update
   *   }
   * })
  **/
  upsert<T extends addressUpsertArgs>(
    args: Subset<T, addressUpsertArgs>
  ): CheckSelect<T, Prisma__addressClient<address>, Prisma__addressClient<addressGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyaddressArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateAddressArgs>(args: Subset<T, AggregateAddressArgs>): Promise<GetAddressAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for address.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__addressClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>;

  order<T extends FindManyorderArgs = {}>(args?: Subset<T, FindManyorderArgs>): CheckSelect<T, Promise<Array<order>>, Promise<Array<orderGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * address findOne
 */
export type FindOneaddressArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
  /**
   * Filter, which address to fetch.
  **/
  where: addressWhereUniqueInput
}


/**
 * address findMany
 */
export type FindManyaddressArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
  /**
   * Filter, which addresses to fetch.
  **/
  where?: addressWhereInput
  /**
   * Determine the order of the addresses to fetch.
  **/
  orderBy?: Enumerable<addressOrderByInput>
  /**
   * Sets the position for listing addresses.
  **/
  cursor?: addressWhereUniqueInput
  /**
   * The number of addresses to fetch. If negative number, it will take addresses before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` addresses.
  **/
  skip?: number
  distinct?: Enumerable<AddressDistinctFieldEnum>
}


/**
 * address create
 */
export type addressCreateArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
  /**
   * The data needed to create a address.
  **/
  data: addressCreateInput
}


/**
 * address update
 */
export type addressUpdateArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
  /**
   * The data needed to update a address.
  **/
  data: addressUpdateInput
  /**
   * Choose, which address to update.
  **/
  where: addressWhereUniqueInput
}


/**
 * address updateMany
 */
export type addressUpdateManyArgs = {
  data: addressUpdateManyMutationInput
  where?: addressWhereInput
}


/**
 * address upsert
 */
export type addressUpsertArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
  /**
   * The filter to search for the address to update in case it exists.
  **/
  where: addressWhereUniqueInput
  /**
   * In case the address found by the `where` argument doesn't exist, create a new address with this data.
  **/
  create: addressCreateInput
  /**
   * In case the address was found with the provided `where` argument, update it with this data.
  **/
  update: addressUpdateInput
}


/**
 * address delete
 */
export type addressDeleteArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
  /**
   * Filter which address to delete.
  **/
  where: addressWhereUniqueInput
}


/**
 * address deleteMany
 */
export type addressDeleteManyArgs = {
  where?: addressWhereInput
}


/**
 * address without action
 */
export type addressArgs = {
  /**
   * Select specific fields to fetch from the address
  **/
  select?: addressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: addressInclude | null
}



/**
 * Model dish
 */

export type dish = {
  id: number
  name: string
  sizes: string[]
  ingredients: string[]
  price: number
  restaurant_id: number
  ingredientchoice: JsonValue | null
  additions: JsonValue | null
}


export type AggregateDish = {
  count: number
  avg: DishAvgAggregateOutputType | null
  sum: DishSumAggregateOutputType | null
  min: DishMinAggregateOutputType | null
  max: DishMaxAggregateOutputType | null
}

export type DishAvgAggregateOutputType = {
  id: number
  price: number
  restaurant_id: number
}

export type DishSumAggregateOutputType = {
  id: number
  price: number
  restaurant_id: number
}

export type DishMinAggregateOutputType = {
  id: number
  price: number
  restaurant_id: number
}

export type DishMaxAggregateOutputType = {
  id: number
  price: number
  restaurant_id: number
}


export type DishAvgAggregateInputType = {
  id?: true
  price?: true
  restaurant_id?: true
}

export type DishSumAggregateInputType = {
  id?: true
  price?: true
  restaurant_id?: true
}

export type DishMinAggregateInputType = {
  id?: true
  price?: true
  restaurant_id?: true
}

export type DishMaxAggregateInputType = {
  id?: true
  price?: true
  restaurant_id?: true
}

export type AggregateDishArgs = {
  where?: dishWhereInput
  orderBy?: Enumerable<dishOrderByInput>
  cursor?: dishWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<DishDistinctFieldEnum>
  count?: true
  avg?: DishAvgAggregateInputType
  sum?: DishSumAggregateInputType
  min?: DishMinAggregateInputType
  max?: DishMaxAggregateInputType
}

export type GetDishAggregateType<T extends AggregateDishArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetDishAggregateScalarType<T[P]>
}

export type GetDishAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof DishAvgAggregateOutputType ? DishAvgAggregateOutputType[P] : never
}
    
    

export type dishSelect = {
  id?: boolean
  name?: boolean
  sizes?: boolean
  ingredients?: boolean
  price?: boolean
  restaurant_id?: boolean
  ingredientchoice?: boolean
  additions?: boolean
  restaurant?: boolean | restaurantArgs
  orderitem?: boolean | FindManyorderitemArgs
}

export type dishInclude = {
  restaurant?: boolean | restaurantArgs
  orderitem?: boolean | FindManyorderitemArgs
}

export type dishGetPayload<
  S extends boolean | null | undefined | dishArgs,
  U = keyof S
> = S extends true
  ? dish
  : S extends undefined
  ? never
  : S extends dishArgs | FindManydishArgs
  ? 'include' extends U
    ? dish  & {
      [P in TrueKeys<S['include']>]:
      P extends 'restaurant'
      ? restaurantGetPayload<S['include'][P]> :
      P extends 'orderitem'
      ? Array<orderitemGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof dish ? dish[P]
: 
      P extends 'restaurant'
      ? restaurantGetPayload<S['select'][P]> :
      P extends 'orderitem'
      ? Array<orderitemGetPayload<S['select'][P]>> : never
    }
  : dish
: dish


export interface dishDelegate {
  /**
   * Find zero or one Dish.
   * @param {FindOnedishArgs} args - Arguments to find a Dish
   * @example
   * // Get one Dish
   * const dish = await prisma.dish.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnedishArgs>(
    args: Subset<T, FindOnedishArgs>
  ): CheckSelect<T, Prisma__dishClient<dish | null>, Prisma__dishClient<dishGetPayload<T> | null>>
  /**
   * Find zero or more Dishes.
   * @param {FindManydishArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Dishes
   * const dishes = await prisma.dish.findMany()
   * 
   * // Get first 10 Dishes
   * const dishes = await prisma.dish.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const dishWithIdOnly = await prisma.dish.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManydishArgs>(
    args?: Subset<T, FindManydishArgs>
  ): CheckSelect<T, Promise<Array<dish>>, Promise<Array<dishGetPayload<T>>>>
  /**
   * Create a Dish.
   * @param {dishCreateArgs} args - Arguments to create a Dish.
   * @example
   * // Create one Dish
   * const Dish = await prisma.dish.create({
   *   data: {
   *     // ... data to create a Dish
   *   }
   * })
   * 
  **/
  create<T extends dishCreateArgs>(
    args: Subset<T, dishCreateArgs>
  ): CheckSelect<T, Prisma__dishClient<dish>, Prisma__dishClient<dishGetPayload<T>>>
  /**
   * Delete a Dish.
   * @param {dishDeleteArgs} args - Arguments to delete one Dish.
   * @example
   * // Delete one Dish
   * const Dish = await prisma.dish.delete({
   *   where: {
   *     // ... filter to delete one Dish
   *   }
   * })
   * 
  **/
  delete<T extends dishDeleteArgs>(
    args: Subset<T, dishDeleteArgs>
  ): CheckSelect<T, Prisma__dishClient<dish>, Prisma__dishClient<dishGetPayload<T>>>
  /**
   * Update one Dish.
   * @param {dishUpdateArgs} args - Arguments to update one Dish.
   * @example
   * // Update one Dish
   * const dish = await prisma.dish.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends dishUpdateArgs>(
    args: Subset<T, dishUpdateArgs>
  ): CheckSelect<T, Prisma__dishClient<dish>, Prisma__dishClient<dishGetPayload<T>>>
  /**
   * Delete zero or more Dishes.
   * @param {dishDeleteManyArgs} args - Arguments to filter Dishes to delete.
   * @example
   * // Delete a few Dishes
   * const { count } = await prisma.dish.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends dishDeleteManyArgs>(
    args: Subset<T, dishDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Dishes.
   * @param {dishUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Dishes
   * const dish = await prisma.dish.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends dishUpdateManyArgs>(
    args: Subset<T, dishUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Dish.
   * @param {dishUpsertArgs} args - Arguments to update or create a Dish.
   * @example
   * // Update or create a Dish
   * const dish = await prisma.dish.upsert({
   *   create: {
   *     // ... data to create a Dish
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Dish we want to update
   *   }
   * })
  **/
  upsert<T extends dishUpsertArgs>(
    args: Subset<T, dishUpsertArgs>
  ): CheckSelect<T, Prisma__dishClient<dish>, Prisma__dishClient<dishGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManydishArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateDishArgs>(args: Subset<T, AggregateDishArgs>): Promise<GetDishAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for dish.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__dishClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  restaurant<T extends restaurantArgs = {}>(args?: Subset<T, restaurantArgs>): CheckSelect<T, Prisma__restaurantClient<restaurant | null>, Prisma__restaurantClient<restaurantGetPayload<T> | null>>;

  orderitem<T extends FindManyorderitemArgs = {}>(args?: Subset<T, FindManyorderitemArgs>): CheckSelect<T, Promise<Array<orderitem>>, Promise<Array<orderitemGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * dish findOne
 */
export type FindOnedishArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
  /**
   * Filter, which dish to fetch.
  **/
  where: dishWhereUniqueInput
}


/**
 * dish findMany
 */
export type FindManydishArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
  /**
   * Filter, which dishes to fetch.
  **/
  where?: dishWhereInput
  /**
   * Determine the order of the dishes to fetch.
  **/
  orderBy?: Enumerable<dishOrderByInput>
  /**
   * Sets the position for listing dishes.
  **/
  cursor?: dishWhereUniqueInput
  /**
   * The number of dishes to fetch. If negative number, it will take dishes before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` dishes.
  **/
  skip?: number
  distinct?: Enumerable<DishDistinctFieldEnum>
}


/**
 * dish create
 */
export type dishCreateArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
  /**
   * The data needed to create a dish.
  **/
  data: dishCreateInput
}


/**
 * dish update
 */
export type dishUpdateArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
  /**
   * The data needed to update a dish.
  **/
  data: dishUpdateInput
  /**
   * Choose, which dish to update.
  **/
  where: dishWhereUniqueInput
}


/**
 * dish updateMany
 */
export type dishUpdateManyArgs = {
  data: dishUpdateManyMutationInput
  where?: dishWhereInput
}


/**
 * dish upsert
 */
export type dishUpsertArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
  /**
   * The filter to search for the dish to update in case it exists.
  **/
  where: dishWhereUniqueInput
  /**
   * In case the dish found by the `where` argument doesn't exist, create a new dish with this data.
  **/
  create: dishCreateInput
  /**
   * In case the dish was found with the provided `where` argument, update it with this data.
  **/
  update: dishUpdateInput
}


/**
 * dish delete
 */
export type dishDeleteArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
  /**
   * Filter which dish to delete.
  **/
  where: dishWhereUniqueInput
}


/**
 * dish deleteMany
 */
export type dishDeleteManyArgs = {
  where?: dishWhereInput
}


/**
 * dish without action
 */
export type dishArgs = {
  /**
   * Select specific fields to fetch from the dish
  **/
  select?: dishSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: dishInclude | null
}



/**
 * Model order
 */

export type order = {
  id: number
  user_id: number
  date: Date
  status_id: number
  quantity: number
  amount: number
  address_id: number
  phone: string
}


export type AggregateOrder = {
  count: number
  avg: OrderAvgAggregateOutputType | null
  sum: OrderSumAggregateOutputType | null
  min: OrderMinAggregateOutputType | null
  max: OrderMaxAggregateOutputType | null
}

export type OrderAvgAggregateOutputType = {
  id: number
  user_id: number
  status_id: number
  quantity: number
  amount: number
  address_id: number
}

export type OrderSumAggregateOutputType = {
  id: number
  user_id: number
  status_id: number
  quantity: number
  amount: number
  address_id: number
}

export type OrderMinAggregateOutputType = {
  id: number
  user_id: number
  status_id: number
  quantity: number
  amount: number
  address_id: number
}

export type OrderMaxAggregateOutputType = {
  id: number
  user_id: number
  status_id: number
  quantity: number
  amount: number
  address_id: number
}


export type OrderAvgAggregateInputType = {
  id?: true
  user_id?: true
  status_id?: true
  quantity?: true
  amount?: true
  address_id?: true
}

export type OrderSumAggregateInputType = {
  id?: true
  user_id?: true
  status_id?: true
  quantity?: true
  amount?: true
  address_id?: true
}

export type OrderMinAggregateInputType = {
  id?: true
  user_id?: true
  status_id?: true
  quantity?: true
  amount?: true
  address_id?: true
}

export type OrderMaxAggregateInputType = {
  id?: true
  user_id?: true
  status_id?: true
  quantity?: true
  amount?: true
  address_id?: true
}

export type AggregateOrderArgs = {
  where?: orderWhereInput
  orderBy?: Enumerable<orderOrderByInput>
  cursor?: orderWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OrderDistinctFieldEnum>
  count?: true
  avg?: OrderAvgAggregateInputType
  sum?: OrderSumAggregateInputType
  min?: OrderMinAggregateInputType
  max?: OrderMaxAggregateInputType
}

export type GetOrderAggregateType<T extends AggregateOrderArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetOrderAggregateScalarType<T[P]>
}

export type GetOrderAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof OrderAvgAggregateOutputType ? OrderAvgAggregateOutputType[P] : never
}
    
    

export type orderSelect = {
  id?: boolean
  user_id?: boolean
  date?: boolean
  status_id?: boolean
  quantity?: boolean
  amount?: boolean
  address_id?: boolean
  phone?: boolean
  address?: boolean | addressArgs
  status?: boolean | statusArgs
  user?: boolean | userArgs
  orderitem?: boolean | FindManyorderitemArgs
}

export type orderInclude = {
  address?: boolean | addressArgs
  status?: boolean | statusArgs
  user?: boolean | userArgs
  orderitem?: boolean | FindManyorderitemArgs
}

export type orderGetPayload<
  S extends boolean | null | undefined | orderArgs,
  U = keyof S
> = S extends true
  ? order
  : S extends undefined
  ? never
  : S extends orderArgs | FindManyorderArgs
  ? 'include' extends U
    ? order  & {
      [P in TrueKeys<S['include']>]:
      P extends 'address'
      ? addressGetPayload<S['include'][P]> :
      P extends 'status'
      ? statusGetPayload<S['include'][P]> :
      P extends 'user'
      ? userGetPayload<S['include'][P]> :
      P extends 'orderitem'
      ? Array<orderitemGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof order ? order[P]
: 
      P extends 'address'
      ? addressGetPayload<S['select'][P]> :
      P extends 'status'
      ? statusGetPayload<S['select'][P]> :
      P extends 'user'
      ? userGetPayload<S['select'][P]> :
      P extends 'orderitem'
      ? Array<orderitemGetPayload<S['select'][P]>> : never
    }
  : order
: order


export interface orderDelegate {
  /**
   * Find zero or one Order.
   * @param {FindOneorderArgs} args - Arguments to find a Order
   * @example
   * // Get one Order
   * const order = await prisma.order.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneorderArgs>(
    args: Subset<T, FindOneorderArgs>
  ): CheckSelect<T, Prisma__orderClient<order | null>, Prisma__orderClient<orderGetPayload<T> | null>>
  /**
   * Find zero or more Orders.
   * @param {FindManyorderArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Orders
   * const orders = await prisma.order.findMany()
   * 
   * // Get first 10 Orders
   * const orders = await prisma.order.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyorderArgs>(
    args?: Subset<T, FindManyorderArgs>
  ): CheckSelect<T, Promise<Array<order>>, Promise<Array<orderGetPayload<T>>>>
  /**
   * Create a Order.
   * @param {orderCreateArgs} args - Arguments to create a Order.
   * @example
   * // Create one Order
   * const Order = await prisma.order.create({
   *   data: {
   *     // ... data to create a Order
   *   }
   * })
   * 
  **/
  create<T extends orderCreateArgs>(
    args: Subset<T, orderCreateArgs>
  ): CheckSelect<T, Prisma__orderClient<order>, Prisma__orderClient<orderGetPayload<T>>>
  /**
   * Delete a Order.
   * @param {orderDeleteArgs} args - Arguments to delete one Order.
   * @example
   * // Delete one Order
   * const Order = await prisma.order.delete({
   *   where: {
   *     // ... filter to delete one Order
   *   }
   * })
   * 
  **/
  delete<T extends orderDeleteArgs>(
    args: Subset<T, orderDeleteArgs>
  ): CheckSelect<T, Prisma__orderClient<order>, Prisma__orderClient<orderGetPayload<T>>>
  /**
   * Update one Order.
   * @param {orderUpdateArgs} args - Arguments to update one Order.
   * @example
   * // Update one Order
   * const order = await prisma.order.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends orderUpdateArgs>(
    args: Subset<T, orderUpdateArgs>
  ): CheckSelect<T, Prisma__orderClient<order>, Prisma__orderClient<orderGetPayload<T>>>
  /**
   * Delete zero or more Orders.
   * @param {orderDeleteManyArgs} args - Arguments to filter Orders to delete.
   * @example
   * // Delete a few Orders
   * const { count } = await prisma.order.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends orderDeleteManyArgs>(
    args: Subset<T, orderDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Orders.
   * @param {orderUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Orders
   * const order = await prisma.order.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends orderUpdateManyArgs>(
    args: Subset<T, orderUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Order.
   * @param {orderUpsertArgs} args - Arguments to update or create a Order.
   * @example
   * // Update or create a Order
   * const order = await prisma.order.upsert({
   *   create: {
   *     // ... data to create a Order
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Order we want to update
   *   }
   * })
  **/
  upsert<T extends orderUpsertArgs>(
    args: Subset<T, orderUpsertArgs>
  ): CheckSelect<T, Prisma__orderClient<order>, Prisma__orderClient<orderGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyorderArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateOrderArgs>(args: Subset<T, AggregateOrderArgs>): Promise<GetOrderAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for order.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__orderClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  address<T extends addressArgs = {}>(args?: Subset<T, addressArgs>): CheckSelect<T, Prisma__addressClient<address | null>, Prisma__addressClient<addressGetPayload<T> | null>>;

  status<T extends statusArgs = {}>(args?: Subset<T, statusArgs>): CheckSelect<T, Prisma__statusClient<status | null>, Prisma__statusClient<statusGetPayload<T> | null>>;

  user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>;

  orderitem<T extends FindManyorderitemArgs = {}>(args?: Subset<T, FindManyorderitemArgs>): CheckSelect<T, Promise<Array<orderitem>>, Promise<Array<orderitemGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * order findOne
 */
export type FindOneorderArgs = {
  /**
   * Select specific fields to fetch from the order
  **/
  select?: orderSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderInclude | null
  /**
   * Filter, which order to fetch.
  **/
  where: orderWhereUniqueInput
}


/**
 * order findMany
 */
export type FindManyorderArgs = {
  /**
   * Select specific fields to fetch from the order
  **/
  select?: orderSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderInclude | null
  /**
   * Filter, which orders to fetch.
  **/
  where?: orderWhereInput
  /**
   * Determine the order of the orders to fetch.
  **/
  orderBy?: Enumerable<orderOrderByInput>
  /**
   * Sets the position for listing orders.
  **/
  cursor?: orderWhereUniqueInput
  /**
   * The number of orders to fetch. If negative number, it will take orders before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` orders.
  **/
  skip?: number
  distinct?: Enumerable<OrderDistinctFieldEnum>
}


/**
 * order create
 */
export type orderCreateArgs = {
  /**
   * Select specific fields to fetch from the order
  **/
  select?: orderSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderInclude | null
  /**
   * The data needed to create a order.
  **/
  data: orderCreateInput
}


/**
 * order update
 */
export type orderUpdateArgs = {
  /**
   * Select specific fields to fetch from the order
  **/
  select?: orderSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderInclude | null
  /**
   * The data needed to update a order.
  **/
  data: orderUpdateInput
  /**
   * Choose, which order to update.
  **/
  where: orderWhereUniqueInput
}


/**
 * order updateMany
 */
export type orderUpdateManyArgs = {
  data: orderUpdateManyMutationInput
  where?: orderWhereInput
}


/**
 * order upsert
 */
export type orderUpsertArgs = {
  /**
   * Select specific fields to fetch from the order
  **/
  select?: orderSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderInclude | null
  /**
   * The filter to search for the order to update in case it exists.
  **/
  where: orderWhereUniqueInput
  /**
   * In case the order found by the `where` argument doesn't exist, create a new order with this data.
  **/
  create: orderCreateInput
  /**
   * In case the order was found with the provided `where` argument, update it with this data.
  **/
  update: orderUpdateInput
}


/**
 * order delete
 */
export type orderDeleteArgs = {
  /**
   * Select specific fields to fetch from the order
  **/
  select?: orderSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderInclude | null
  /**
   * Filter which order to delete.
  **/
  where: orderWhereUniqueInput
}


/**
 * order deleteMany
 */
export type orderDeleteManyArgs = {
  where?: orderWhereInput
}


/**
 * order without action
 */
export type orderArgs = {
  /**
   * Select specific fields to fetch from the order
  **/
  select?: orderSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderInclude | null
}



/**
 * Model orderitem
 */

export type orderitem = {
  id: number
  quantity: number
  item_id: number
  order_id: number
}


export type AggregateOrderitem = {
  count: number
  avg: OrderitemAvgAggregateOutputType | null
  sum: OrderitemSumAggregateOutputType | null
  min: OrderitemMinAggregateOutputType | null
  max: OrderitemMaxAggregateOutputType | null
}

export type OrderitemAvgAggregateOutputType = {
  id: number
  quantity: number
  item_id: number
  order_id: number
}

export type OrderitemSumAggregateOutputType = {
  id: number
  quantity: number
  item_id: number
  order_id: number
}

export type OrderitemMinAggregateOutputType = {
  id: number
  quantity: number
  item_id: number
  order_id: number
}

export type OrderitemMaxAggregateOutputType = {
  id: number
  quantity: number
  item_id: number
  order_id: number
}


export type OrderitemAvgAggregateInputType = {
  id?: true
  quantity?: true
  item_id?: true
  order_id?: true
}

export type OrderitemSumAggregateInputType = {
  id?: true
  quantity?: true
  item_id?: true
  order_id?: true
}

export type OrderitemMinAggregateInputType = {
  id?: true
  quantity?: true
  item_id?: true
  order_id?: true
}

export type OrderitemMaxAggregateInputType = {
  id?: true
  quantity?: true
  item_id?: true
  order_id?: true
}

export type AggregateOrderitemArgs = {
  where?: orderitemWhereInput
  orderBy?: Enumerable<orderitemOrderByInput>
  cursor?: orderitemWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OrderitemDistinctFieldEnum>
  count?: true
  avg?: OrderitemAvgAggregateInputType
  sum?: OrderitemSumAggregateInputType
  min?: OrderitemMinAggregateInputType
  max?: OrderitemMaxAggregateInputType
}

export type GetOrderitemAggregateType<T extends AggregateOrderitemArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetOrderitemAggregateScalarType<T[P]>
}

export type GetOrderitemAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof OrderitemAvgAggregateOutputType ? OrderitemAvgAggregateOutputType[P] : never
}
    
    

export type orderitemSelect = {
  id?: boolean
  quantity?: boolean
  item_id?: boolean
  order_id?: boolean
  dish?: boolean | dishArgs
  order?: boolean | orderArgs
}

export type orderitemInclude = {
  dish?: boolean | dishArgs
  order?: boolean | orderArgs
}

export type orderitemGetPayload<
  S extends boolean | null | undefined | orderitemArgs,
  U = keyof S
> = S extends true
  ? orderitem
  : S extends undefined
  ? never
  : S extends orderitemArgs | FindManyorderitemArgs
  ? 'include' extends U
    ? orderitem  & {
      [P in TrueKeys<S['include']>]:
      P extends 'dish'
      ? dishGetPayload<S['include'][P]> :
      P extends 'order'
      ? orderGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof orderitem ? orderitem[P]
: 
      P extends 'dish'
      ? dishGetPayload<S['select'][P]> :
      P extends 'order'
      ? orderGetPayload<S['select'][P]> : never
    }
  : orderitem
: orderitem


export interface orderitemDelegate {
  /**
   * Find zero or one Orderitem.
   * @param {FindOneorderitemArgs} args - Arguments to find a Orderitem
   * @example
   * // Get one Orderitem
   * const orderitem = await prisma.orderitem.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneorderitemArgs>(
    args: Subset<T, FindOneorderitemArgs>
  ): CheckSelect<T, Prisma__orderitemClient<orderitem | null>, Prisma__orderitemClient<orderitemGetPayload<T> | null>>
  /**
   * Find zero or more Orderitems.
   * @param {FindManyorderitemArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Orderitems
   * const orderitems = await prisma.orderitem.findMany()
   * 
   * // Get first 10 Orderitems
   * const orderitems = await prisma.orderitem.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const orderitemWithIdOnly = await prisma.orderitem.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyorderitemArgs>(
    args?: Subset<T, FindManyorderitemArgs>
  ): CheckSelect<T, Promise<Array<orderitem>>, Promise<Array<orderitemGetPayload<T>>>>
  /**
   * Create a Orderitem.
   * @param {orderitemCreateArgs} args - Arguments to create a Orderitem.
   * @example
   * // Create one Orderitem
   * const Orderitem = await prisma.orderitem.create({
   *   data: {
   *     // ... data to create a Orderitem
   *   }
   * })
   * 
  **/
  create<T extends orderitemCreateArgs>(
    args: Subset<T, orderitemCreateArgs>
  ): CheckSelect<T, Prisma__orderitemClient<orderitem>, Prisma__orderitemClient<orderitemGetPayload<T>>>
  /**
   * Delete a Orderitem.
   * @param {orderitemDeleteArgs} args - Arguments to delete one Orderitem.
   * @example
   * // Delete one Orderitem
   * const Orderitem = await prisma.orderitem.delete({
   *   where: {
   *     // ... filter to delete one Orderitem
   *   }
   * })
   * 
  **/
  delete<T extends orderitemDeleteArgs>(
    args: Subset<T, orderitemDeleteArgs>
  ): CheckSelect<T, Prisma__orderitemClient<orderitem>, Prisma__orderitemClient<orderitemGetPayload<T>>>
  /**
   * Update one Orderitem.
   * @param {orderitemUpdateArgs} args - Arguments to update one Orderitem.
   * @example
   * // Update one Orderitem
   * const orderitem = await prisma.orderitem.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends orderitemUpdateArgs>(
    args: Subset<T, orderitemUpdateArgs>
  ): CheckSelect<T, Prisma__orderitemClient<orderitem>, Prisma__orderitemClient<orderitemGetPayload<T>>>
  /**
   * Delete zero or more Orderitems.
   * @param {orderitemDeleteManyArgs} args - Arguments to filter Orderitems to delete.
   * @example
   * // Delete a few Orderitems
   * const { count } = await prisma.orderitem.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends orderitemDeleteManyArgs>(
    args: Subset<T, orderitemDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Orderitems.
   * @param {orderitemUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Orderitems
   * const orderitem = await prisma.orderitem.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends orderitemUpdateManyArgs>(
    args: Subset<T, orderitemUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Orderitem.
   * @param {orderitemUpsertArgs} args - Arguments to update or create a Orderitem.
   * @example
   * // Update or create a Orderitem
   * const orderitem = await prisma.orderitem.upsert({
   *   create: {
   *     // ... data to create a Orderitem
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Orderitem we want to update
   *   }
   * })
  **/
  upsert<T extends orderitemUpsertArgs>(
    args: Subset<T, orderitemUpsertArgs>
  ): CheckSelect<T, Prisma__orderitemClient<orderitem>, Prisma__orderitemClient<orderitemGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyorderitemArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateOrderitemArgs>(args: Subset<T, AggregateOrderitemArgs>): Promise<GetOrderitemAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for orderitem.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__orderitemClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  dish<T extends dishArgs = {}>(args?: Subset<T, dishArgs>): CheckSelect<T, Prisma__dishClient<dish | null>, Prisma__dishClient<dishGetPayload<T> | null>>;

  order<T extends orderArgs = {}>(args?: Subset<T, orderArgs>): CheckSelect<T, Prisma__orderClient<order | null>, Prisma__orderClient<orderGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * orderitem findOne
 */
export type FindOneorderitemArgs = {
  /**
   * Select specific fields to fetch from the orderitem
  **/
  select?: orderitemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderitemInclude | null
  /**
   * Filter, which orderitem to fetch.
  **/
  where: orderitemWhereUniqueInput
}


/**
 * orderitem findMany
 */
export type FindManyorderitemArgs = {
  /**
   * Select specific fields to fetch from the orderitem
  **/
  select?: orderitemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderitemInclude | null
  /**
   * Filter, which orderitems to fetch.
  **/
  where?: orderitemWhereInput
  /**
   * Determine the order of the orderitems to fetch.
  **/
  orderBy?: Enumerable<orderitemOrderByInput>
  /**
   * Sets the position for listing orderitems.
  **/
  cursor?: orderitemWhereUniqueInput
  /**
   * The number of orderitems to fetch. If negative number, it will take orderitems before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` orderitems.
  **/
  skip?: number
  distinct?: Enumerable<OrderitemDistinctFieldEnum>
}


/**
 * orderitem create
 */
export type orderitemCreateArgs = {
  /**
   * Select specific fields to fetch from the orderitem
  **/
  select?: orderitemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderitemInclude | null
  /**
   * The data needed to create a orderitem.
  **/
  data: orderitemCreateInput
}


/**
 * orderitem update
 */
export type orderitemUpdateArgs = {
  /**
   * Select specific fields to fetch from the orderitem
  **/
  select?: orderitemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderitemInclude | null
  /**
   * The data needed to update a orderitem.
  **/
  data: orderitemUpdateInput
  /**
   * Choose, which orderitem to update.
  **/
  where: orderitemWhereUniqueInput
}


/**
 * orderitem updateMany
 */
export type orderitemUpdateManyArgs = {
  data: orderitemUpdateManyMutationInput
  where?: orderitemWhereInput
}


/**
 * orderitem upsert
 */
export type orderitemUpsertArgs = {
  /**
   * Select specific fields to fetch from the orderitem
  **/
  select?: orderitemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderitemInclude | null
  /**
   * The filter to search for the orderitem to update in case it exists.
  **/
  where: orderitemWhereUniqueInput
  /**
   * In case the orderitem found by the `where` argument doesn't exist, create a new orderitem with this data.
  **/
  create: orderitemCreateInput
  /**
   * In case the orderitem was found with the provided `where` argument, update it with this data.
  **/
  update: orderitemUpdateInput
}


/**
 * orderitem delete
 */
export type orderitemDeleteArgs = {
  /**
   * Select specific fields to fetch from the orderitem
  **/
  select?: orderitemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderitemInclude | null
  /**
   * Filter which orderitem to delete.
  **/
  where: orderitemWhereUniqueInput
}


/**
 * orderitem deleteMany
 */
export type orderitemDeleteManyArgs = {
  where?: orderitemWhereInput
}


/**
 * orderitem without action
 */
export type orderitemArgs = {
  /**
   * Select specific fields to fetch from the orderitem
  **/
  select?: orderitemSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: orderitemInclude | null
}



/**
 * Model owneraccount
 */

export type owneraccount = {
  id: number
  client_id: number | null
}


export type AggregateOwneraccount = {
  count: number
  avg: OwneraccountAvgAggregateOutputType | null
  sum: OwneraccountSumAggregateOutputType | null
  min: OwneraccountMinAggregateOutputType | null
  max: OwneraccountMaxAggregateOutputType | null
}

export type OwneraccountAvgAggregateOutputType = {
  id: number
  client_id: number
}

export type OwneraccountSumAggregateOutputType = {
  id: number
  client_id: number | null
}

export type OwneraccountMinAggregateOutputType = {
  id: number
  client_id: number | null
}

export type OwneraccountMaxAggregateOutputType = {
  id: number
  client_id: number | null
}


export type OwneraccountAvgAggregateInputType = {
  id?: true
  client_id?: true
}

export type OwneraccountSumAggregateInputType = {
  id?: true
  client_id?: true
}

export type OwneraccountMinAggregateInputType = {
  id?: true
  client_id?: true
}

export type OwneraccountMaxAggregateInputType = {
  id?: true
  client_id?: true
}

export type AggregateOwneraccountArgs = {
  where?: owneraccountWhereInput
  orderBy?: Enumerable<owneraccountOrderByInput>
  cursor?: owneraccountWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OwneraccountDistinctFieldEnum>
  count?: true
  avg?: OwneraccountAvgAggregateInputType
  sum?: OwneraccountSumAggregateInputType
  min?: OwneraccountMinAggregateInputType
  max?: OwneraccountMaxAggregateInputType
}

export type GetOwneraccountAggregateType<T extends AggregateOwneraccountArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetOwneraccountAggregateScalarType<T[P]>
}

export type GetOwneraccountAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof OwneraccountAvgAggregateOutputType ? OwneraccountAvgAggregateOutputType[P] : never
}
    
    

export type owneraccountSelect = {
  id?: boolean
  client_id?: boolean
  user?: boolean | userArgs
}

export type owneraccountInclude = {
  user?: boolean | userArgs
}

export type owneraccountGetPayload<
  S extends boolean | null | undefined | owneraccountArgs,
  U = keyof S
> = S extends true
  ? owneraccount
  : S extends undefined
  ? never
  : S extends owneraccountArgs | FindManyowneraccountArgs
  ? 'include' extends U
    ? owneraccount  & {
      [P in TrueKeys<S['include']>]:
      P extends 'user'
      ? userGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof owneraccount ? owneraccount[P]
: 
      P extends 'user'
      ? userGetPayload<S['select'][P]> | null : never
    }
  : owneraccount
: owneraccount


export interface owneraccountDelegate {
  /**
   * Find zero or one Owneraccount.
   * @param {FindOneowneraccountArgs} args - Arguments to find a Owneraccount
   * @example
   * // Get one Owneraccount
   * const owneraccount = await prisma.owneraccount.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneowneraccountArgs>(
    args: Subset<T, FindOneowneraccountArgs>
  ): CheckSelect<T, Prisma__owneraccountClient<owneraccount | null>, Prisma__owneraccountClient<owneraccountGetPayload<T> | null>>
  /**
   * Find zero or more Owneraccounts.
   * @param {FindManyowneraccountArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Owneraccounts
   * const owneraccounts = await prisma.owneraccount.findMany()
   * 
   * // Get first 10 Owneraccounts
   * const owneraccounts = await prisma.owneraccount.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const owneraccountWithIdOnly = await prisma.owneraccount.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyowneraccountArgs>(
    args?: Subset<T, FindManyowneraccountArgs>
  ): CheckSelect<T, Promise<Array<owneraccount>>, Promise<Array<owneraccountGetPayload<T>>>>
  /**
   * Create a Owneraccount.
   * @param {owneraccountCreateArgs} args - Arguments to create a Owneraccount.
   * @example
   * // Create one Owneraccount
   * const Owneraccount = await prisma.owneraccount.create({
   *   data: {
   *     // ... data to create a Owneraccount
   *   }
   * })
   * 
  **/
  create<T extends owneraccountCreateArgs>(
    args: Subset<T, owneraccountCreateArgs>
  ): CheckSelect<T, Prisma__owneraccountClient<owneraccount>, Prisma__owneraccountClient<owneraccountGetPayload<T>>>
  /**
   * Delete a Owneraccount.
   * @param {owneraccountDeleteArgs} args - Arguments to delete one Owneraccount.
   * @example
   * // Delete one Owneraccount
   * const Owneraccount = await prisma.owneraccount.delete({
   *   where: {
   *     // ... filter to delete one Owneraccount
   *   }
   * })
   * 
  **/
  delete<T extends owneraccountDeleteArgs>(
    args: Subset<T, owneraccountDeleteArgs>
  ): CheckSelect<T, Prisma__owneraccountClient<owneraccount>, Prisma__owneraccountClient<owneraccountGetPayload<T>>>
  /**
   * Update one Owneraccount.
   * @param {owneraccountUpdateArgs} args - Arguments to update one Owneraccount.
   * @example
   * // Update one Owneraccount
   * const owneraccount = await prisma.owneraccount.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends owneraccountUpdateArgs>(
    args: Subset<T, owneraccountUpdateArgs>
  ): CheckSelect<T, Prisma__owneraccountClient<owneraccount>, Prisma__owneraccountClient<owneraccountGetPayload<T>>>
  /**
   * Delete zero or more Owneraccounts.
   * @param {owneraccountDeleteManyArgs} args - Arguments to filter Owneraccounts to delete.
   * @example
   * // Delete a few Owneraccounts
   * const { count } = await prisma.owneraccount.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends owneraccountDeleteManyArgs>(
    args: Subset<T, owneraccountDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Owneraccounts.
   * @param {owneraccountUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Owneraccounts
   * const owneraccount = await prisma.owneraccount.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends owneraccountUpdateManyArgs>(
    args: Subset<T, owneraccountUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Owneraccount.
   * @param {owneraccountUpsertArgs} args - Arguments to update or create a Owneraccount.
   * @example
   * // Update or create a Owneraccount
   * const owneraccount = await prisma.owneraccount.upsert({
   *   create: {
   *     // ... data to create a Owneraccount
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Owneraccount we want to update
   *   }
   * })
  **/
  upsert<T extends owneraccountUpsertArgs>(
    args: Subset<T, owneraccountUpsertArgs>
  ): CheckSelect<T, Prisma__owneraccountClient<owneraccount>, Prisma__owneraccountClient<owneraccountGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyowneraccountArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateOwneraccountArgs>(args: Subset<T, AggregateOwneraccountArgs>): Promise<GetOwneraccountAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for owneraccount.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__owneraccountClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * owneraccount findOne
 */
export type FindOneowneraccountArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
  /**
   * Filter, which owneraccount to fetch.
  **/
  where: owneraccountWhereUniqueInput
}


/**
 * owneraccount findMany
 */
export type FindManyowneraccountArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
  /**
   * Filter, which owneraccounts to fetch.
  **/
  where?: owneraccountWhereInput
  /**
   * Determine the order of the owneraccounts to fetch.
  **/
  orderBy?: Enumerable<owneraccountOrderByInput>
  /**
   * Sets the position for listing owneraccounts.
  **/
  cursor?: owneraccountWhereUniqueInput
  /**
   * The number of owneraccounts to fetch. If negative number, it will take owneraccounts before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` owneraccounts.
  **/
  skip?: number
  distinct?: Enumerable<OwneraccountDistinctFieldEnum>
}


/**
 * owneraccount create
 */
export type owneraccountCreateArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
  /**
   * The data needed to create a owneraccount.
  **/
  data: owneraccountCreateInput
}


/**
 * owneraccount update
 */
export type owneraccountUpdateArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
  /**
   * The data needed to update a owneraccount.
  **/
  data: owneraccountUpdateInput
  /**
   * Choose, which owneraccount to update.
  **/
  where: owneraccountWhereUniqueInput
}


/**
 * owneraccount updateMany
 */
export type owneraccountUpdateManyArgs = {
  data: owneraccountUpdateManyMutationInput
  where?: owneraccountWhereInput
}


/**
 * owneraccount upsert
 */
export type owneraccountUpsertArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
  /**
   * The filter to search for the owneraccount to update in case it exists.
  **/
  where: owneraccountWhereUniqueInput
  /**
   * In case the owneraccount found by the `where` argument doesn't exist, create a new owneraccount with this data.
  **/
  create: owneraccountCreateInput
  /**
   * In case the owneraccount was found with the provided `where` argument, update it with this data.
  **/
  update: owneraccountUpdateInput
}


/**
 * owneraccount delete
 */
export type owneraccountDeleteArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
  /**
   * Filter which owneraccount to delete.
  **/
  where: owneraccountWhereUniqueInput
}


/**
 * owneraccount deleteMany
 */
export type owneraccountDeleteManyArgs = {
  where?: owneraccountWhereInput
}


/**
 * owneraccount without action
 */
export type owneraccountArgs = {
  /**
   * Select specific fields to fetch from the owneraccount
  **/
  select?: owneraccountSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: owneraccountInclude | null
}



/**
 * Model restaurant
 */

export type restaurant = {
  id: number
  name: string
  type: string
  phone: string
  delivery: number
  deliveryfee: number
  owner_id: number
  address_id: number
}


export type AggregateRestaurant = {
  count: number
  avg: RestaurantAvgAggregateOutputType | null
  sum: RestaurantSumAggregateOutputType | null
  min: RestaurantMinAggregateOutputType | null
  max: RestaurantMaxAggregateOutputType | null
}

export type RestaurantAvgAggregateOutputType = {
  id: number
  delivery: number
  deliveryfee: number
  owner_id: number
  address_id: number
}

export type RestaurantSumAggregateOutputType = {
  id: number
  delivery: number
  deliveryfee: number
  owner_id: number
  address_id: number
}

export type RestaurantMinAggregateOutputType = {
  id: number
  delivery: number
  deliveryfee: number
  owner_id: number
  address_id: number
}

export type RestaurantMaxAggregateOutputType = {
  id: number
  delivery: number
  deliveryfee: number
  owner_id: number
  address_id: number
}


export type RestaurantAvgAggregateInputType = {
  id?: true
  delivery?: true
  deliveryfee?: true
  owner_id?: true
  address_id?: true
}

export type RestaurantSumAggregateInputType = {
  id?: true
  delivery?: true
  deliveryfee?: true
  owner_id?: true
  address_id?: true
}

export type RestaurantMinAggregateInputType = {
  id?: true
  delivery?: true
  deliveryfee?: true
  owner_id?: true
  address_id?: true
}

export type RestaurantMaxAggregateInputType = {
  id?: true
  delivery?: true
  deliveryfee?: true
  owner_id?: true
  address_id?: true
}

export type AggregateRestaurantArgs = {
  where?: restaurantWhereInput
  orderBy?: Enumerable<restaurantOrderByInput>
  cursor?: restaurantWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<RestaurantDistinctFieldEnum>
  count?: true
  avg?: RestaurantAvgAggregateInputType
  sum?: RestaurantSumAggregateInputType
  min?: RestaurantMinAggregateInputType
  max?: RestaurantMaxAggregateInputType
}

export type GetRestaurantAggregateType<T extends AggregateRestaurantArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetRestaurantAggregateScalarType<T[P]>
}

export type GetRestaurantAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof RestaurantAvgAggregateOutputType ? RestaurantAvgAggregateOutputType[P] : never
}
    
    

export type restaurantSelect = {
  id?: boolean
  name?: boolean
  type?: boolean
  phone?: boolean
  delivery?: boolean
  deliveryfee?: boolean
  owner_id?: boolean
  address_id?: boolean
  restaurantaddress?: boolean | restaurantaddressArgs
  user?: boolean | userArgs
  dish?: boolean | FindManydishArgs
  review?: boolean | FindManyreviewArgs
}

export type restaurantInclude = {
  restaurantaddress?: boolean | restaurantaddressArgs
  user?: boolean | userArgs
  dish?: boolean | FindManydishArgs
  review?: boolean | FindManyreviewArgs
}

export type restaurantGetPayload<
  S extends boolean | null | undefined | restaurantArgs,
  U = keyof S
> = S extends true
  ? restaurant
  : S extends undefined
  ? never
  : S extends restaurantArgs | FindManyrestaurantArgs
  ? 'include' extends U
    ? restaurant  & {
      [P in TrueKeys<S['include']>]:
      P extends 'restaurantaddress'
      ? restaurantaddressGetPayload<S['include'][P]> :
      P extends 'user'
      ? userGetPayload<S['include'][P]> :
      P extends 'dish'
      ? Array<dishGetPayload<S['include'][P]>> :
      P extends 'review'
      ? Array<reviewGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof restaurant ? restaurant[P]
: 
      P extends 'restaurantaddress'
      ? restaurantaddressGetPayload<S['select'][P]> :
      P extends 'user'
      ? userGetPayload<S['select'][P]> :
      P extends 'dish'
      ? Array<dishGetPayload<S['select'][P]>> :
      P extends 'review'
      ? Array<reviewGetPayload<S['select'][P]>> : never
    }
  : restaurant
: restaurant


export interface restaurantDelegate {
  /**
   * Find zero or one Restaurant.
   * @param {FindOnerestaurantArgs} args - Arguments to find a Restaurant
   * @example
   * // Get one Restaurant
   * const restaurant = await prisma.restaurant.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnerestaurantArgs>(
    args: Subset<T, FindOnerestaurantArgs>
  ): CheckSelect<T, Prisma__restaurantClient<restaurant | null>, Prisma__restaurantClient<restaurantGetPayload<T> | null>>
  /**
   * Find zero or more Restaurants.
   * @param {FindManyrestaurantArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Restaurants
   * const restaurants = await prisma.restaurant.findMany()
   * 
   * // Get first 10 Restaurants
   * const restaurants = await prisma.restaurant.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const restaurantWithIdOnly = await prisma.restaurant.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyrestaurantArgs>(
    args?: Subset<T, FindManyrestaurantArgs>
  ): CheckSelect<T, Promise<Array<restaurant>>, Promise<Array<restaurantGetPayload<T>>>>
  /**
   * Create a Restaurant.
   * @param {restaurantCreateArgs} args - Arguments to create a Restaurant.
   * @example
   * // Create one Restaurant
   * const Restaurant = await prisma.restaurant.create({
   *   data: {
   *     // ... data to create a Restaurant
   *   }
   * })
   * 
  **/
  create<T extends restaurantCreateArgs>(
    args: Subset<T, restaurantCreateArgs>
  ): CheckSelect<T, Prisma__restaurantClient<restaurant>, Prisma__restaurantClient<restaurantGetPayload<T>>>
  /**
   * Delete a Restaurant.
   * @param {restaurantDeleteArgs} args - Arguments to delete one Restaurant.
   * @example
   * // Delete one Restaurant
   * const Restaurant = await prisma.restaurant.delete({
   *   where: {
   *     // ... filter to delete one Restaurant
   *   }
   * })
   * 
  **/
  delete<T extends restaurantDeleteArgs>(
    args: Subset<T, restaurantDeleteArgs>
  ): CheckSelect<T, Prisma__restaurantClient<restaurant>, Prisma__restaurantClient<restaurantGetPayload<T>>>
  /**
   * Update one Restaurant.
   * @param {restaurantUpdateArgs} args - Arguments to update one Restaurant.
   * @example
   * // Update one Restaurant
   * const restaurant = await prisma.restaurant.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends restaurantUpdateArgs>(
    args: Subset<T, restaurantUpdateArgs>
  ): CheckSelect<T, Prisma__restaurantClient<restaurant>, Prisma__restaurantClient<restaurantGetPayload<T>>>
  /**
   * Delete zero or more Restaurants.
   * @param {restaurantDeleteManyArgs} args - Arguments to filter Restaurants to delete.
   * @example
   * // Delete a few Restaurants
   * const { count } = await prisma.restaurant.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends restaurantDeleteManyArgs>(
    args: Subset<T, restaurantDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Restaurants.
   * @param {restaurantUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Restaurants
   * const restaurant = await prisma.restaurant.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends restaurantUpdateManyArgs>(
    args: Subset<T, restaurantUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Restaurant.
   * @param {restaurantUpsertArgs} args - Arguments to update or create a Restaurant.
   * @example
   * // Update or create a Restaurant
   * const restaurant = await prisma.restaurant.upsert({
   *   create: {
   *     // ... data to create a Restaurant
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Restaurant we want to update
   *   }
   * })
  **/
  upsert<T extends restaurantUpsertArgs>(
    args: Subset<T, restaurantUpsertArgs>
  ): CheckSelect<T, Prisma__restaurantClient<restaurant>, Prisma__restaurantClient<restaurantGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyrestaurantArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateRestaurantArgs>(args: Subset<T, AggregateRestaurantArgs>): Promise<GetRestaurantAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for restaurant.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__restaurantClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  restaurantaddress<T extends restaurantaddressArgs = {}>(args?: Subset<T, restaurantaddressArgs>): CheckSelect<T, Prisma__restaurantaddressClient<restaurantaddress | null>, Prisma__restaurantaddressClient<restaurantaddressGetPayload<T> | null>>;

  user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>;

  dish<T extends FindManydishArgs = {}>(args?: Subset<T, FindManydishArgs>): CheckSelect<T, Promise<Array<dish>>, Promise<Array<dishGetPayload<T>>>>;

  review<T extends FindManyreviewArgs = {}>(args?: Subset<T, FindManyreviewArgs>): CheckSelect<T, Promise<Array<review>>, Promise<Array<reviewGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * restaurant findOne
 */
export type FindOnerestaurantArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
  /**
   * Filter, which restaurant to fetch.
  **/
  where: restaurantWhereUniqueInput
}


/**
 * restaurant findMany
 */
export type FindManyrestaurantArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
  /**
   * Filter, which restaurants to fetch.
  **/
  where?: restaurantWhereInput
  /**
   * Determine the order of the restaurants to fetch.
  **/
  orderBy?: Enumerable<restaurantOrderByInput>
  /**
   * Sets the position for listing restaurants.
  **/
  cursor?: restaurantWhereUniqueInput
  /**
   * The number of restaurants to fetch. If negative number, it will take restaurants before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` restaurants.
  **/
  skip?: number
  distinct?: Enumerable<RestaurantDistinctFieldEnum>
}


/**
 * restaurant create
 */
export type restaurantCreateArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
  /**
   * The data needed to create a restaurant.
  **/
  data: restaurantCreateInput
}


/**
 * restaurant update
 */
export type restaurantUpdateArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
  /**
   * The data needed to update a restaurant.
  **/
  data: restaurantUpdateInput
  /**
   * Choose, which restaurant to update.
  **/
  where: restaurantWhereUniqueInput
}


/**
 * restaurant updateMany
 */
export type restaurantUpdateManyArgs = {
  data: restaurantUpdateManyMutationInput
  where?: restaurantWhereInput
}


/**
 * restaurant upsert
 */
export type restaurantUpsertArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
  /**
   * The filter to search for the restaurant to update in case it exists.
  **/
  where: restaurantWhereUniqueInput
  /**
   * In case the restaurant found by the `where` argument doesn't exist, create a new restaurant with this data.
  **/
  create: restaurantCreateInput
  /**
   * In case the restaurant was found with the provided `where` argument, update it with this data.
  **/
  update: restaurantUpdateInput
}


/**
 * restaurant delete
 */
export type restaurantDeleteArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
  /**
   * Filter which restaurant to delete.
  **/
  where: restaurantWhereUniqueInput
}


/**
 * restaurant deleteMany
 */
export type restaurantDeleteManyArgs = {
  where?: restaurantWhereInput
}


/**
 * restaurant without action
 */
export type restaurantArgs = {
  /**
   * Select specific fields to fetch from the restaurant
  **/
  select?: restaurantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantInclude | null
}



/**
 * Model restaurantaddress
 */

export type restaurantaddress = {
  id: number
  city: string
  street: string
  zip: string
}


export type AggregateRestaurantaddress = {
  count: number
  avg: RestaurantaddressAvgAggregateOutputType | null
  sum: RestaurantaddressSumAggregateOutputType | null
  min: RestaurantaddressMinAggregateOutputType | null
  max: RestaurantaddressMaxAggregateOutputType | null
}

export type RestaurantaddressAvgAggregateOutputType = {
  id: number
}

export type RestaurantaddressSumAggregateOutputType = {
  id: number
}

export type RestaurantaddressMinAggregateOutputType = {
  id: number
}

export type RestaurantaddressMaxAggregateOutputType = {
  id: number
}


export type RestaurantaddressAvgAggregateInputType = {
  id?: true
}

export type RestaurantaddressSumAggregateInputType = {
  id?: true
}

export type RestaurantaddressMinAggregateInputType = {
  id?: true
}

export type RestaurantaddressMaxAggregateInputType = {
  id?: true
}

export type AggregateRestaurantaddressArgs = {
  where?: restaurantaddressWhereInput
  orderBy?: Enumerable<restaurantaddressOrderByInput>
  cursor?: restaurantaddressWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<RestaurantaddressDistinctFieldEnum>
  count?: true
  avg?: RestaurantaddressAvgAggregateInputType
  sum?: RestaurantaddressSumAggregateInputType
  min?: RestaurantaddressMinAggregateInputType
  max?: RestaurantaddressMaxAggregateInputType
}

export type GetRestaurantaddressAggregateType<T extends AggregateRestaurantaddressArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetRestaurantaddressAggregateScalarType<T[P]>
}

export type GetRestaurantaddressAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof RestaurantaddressAvgAggregateOutputType ? RestaurantaddressAvgAggregateOutputType[P] : never
}
    
    

export type restaurantaddressSelect = {
  id?: boolean
  city?: boolean
  street?: boolean
  zip?: boolean
  restaurant?: boolean | FindManyrestaurantArgs
}

export type restaurantaddressInclude = {
  restaurant?: boolean | FindManyrestaurantArgs
}

export type restaurantaddressGetPayload<
  S extends boolean | null | undefined | restaurantaddressArgs,
  U = keyof S
> = S extends true
  ? restaurantaddress
  : S extends undefined
  ? never
  : S extends restaurantaddressArgs | FindManyrestaurantaddressArgs
  ? 'include' extends U
    ? restaurantaddress  & {
      [P in TrueKeys<S['include']>]:
      P extends 'restaurant'
      ? Array<restaurantGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof restaurantaddress ? restaurantaddress[P]
: 
      P extends 'restaurant'
      ? Array<restaurantGetPayload<S['select'][P]>> : never
    }
  : restaurantaddress
: restaurantaddress


export interface restaurantaddressDelegate {
  /**
   * Find zero or one Restaurantaddress.
   * @param {FindOnerestaurantaddressArgs} args - Arguments to find a Restaurantaddress
   * @example
   * // Get one Restaurantaddress
   * const restaurantaddress = await prisma.restaurantaddress.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnerestaurantaddressArgs>(
    args: Subset<T, FindOnerestaurantaddressArgs>
  ): CheckSelect<T, Prisma__restaurantaddressClient<restaurantaddress | null>, Prisma__restaurantaddressClient<restaurantaddressGetPayload<T> | null>>
  /**
   * Find zero or more Restaurantaddresses.
   * @param {FindManyrestaurantaddressArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Restaurantaddresses
   * const restaurantaddresses = await prisma.restaurantaddress.findMany()
   * 
   * // Get first 10 Restaurantaddresses
   * const restaurantaddresses = await prisma.restaurantaddress.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const restaurantaddressWithIdOnly = await prisma.restaurantaddress.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyrestaurantaddressArgs>(
    args?: Subset<T, FindManyrestaurantaddressArgs>
  ): CheckSelect<T, Promise<Array<restaurantaddress>>, Promise<Array<restaurantaddressGetPayload<T>>>>
  /**
   * Create a Restaurantaddress.
   * @param {restaurantaddressCreateArgs} args - Arguments to create a Restaurantaddress.
   * @example
   * // Create one Restaurantaddress
   * const Restaurantaddress = await prisma.restaurantaddress.create({
   *   data: {
   *     // ... data to create a Restaurantaddress
   *   }
   * })
   * 
  **/
  create<T extends restaurantaddressCreateArgs>(
    args: Subset<T, restaurantaddressCreateArgs>
  ): CheckSelect<T, Prisma__restaurantaddressClient<restaurantaddress>, Prisma__restaurantaddressClient<restaurantaddressGetPayload<T>>>
  /**
   * Delete a Restaurantaddress.
   * @param {restaurantaddressDeleteArgs} args - Arguments to delete one Restaurantaddress.
   * @example
   * // Delete one Restaurantaddress
   * const Restaurantaddress = await prisma.restaurantaddress.delete({
   *   where: {
   *     // ... filter to delete one Restaurantaddress
   *   }
   * })
   * 
  **/
  delete<T extends restaurantaddressDeleteArgs>(
    args: Subset<T, restaurantaddressDeleteArgs>
  ): CheckSelect<T, Prisma__restaurantaddressClient<restaurantaddress>, Prisma__restaurantaddressClient<restaurantaddressGetPayload<T>>>
  /**
   * Update one Restaurantaddress.
   * @param {restaurantaddressUpdateArgs} args - Arguments to update one Restaurantaddress.
   * @example
   * // Update one Restaurantaddress
   * const restaurantaddress = await prisma.restaurantaddress.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends restaurantaddressUpdateArgs>(
    args: Subset<T, restaurantaddressUpdateArgs>
  ): CheckSelect<T, Prisma__restaurantaddressClient<restaurantaddress>, Prisma__restaurantaddressClient<restaurantaddressGetPayload<T>>>
  /**
   * Delete zero or more Restaurantaddresses.
   * @param {restaurantaddressDeleteManyArgs} args - Arguments to filter Restaurantaddresses to delete.
   * @example
   * // Delete a few Restaurantaddresses
   * const { count } = await prisma.restaurantaddress.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends restaurantaddressDeleteManyArgs>(
    args: Subset<T, restaurantaddressDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Restaurantaddresses.
   * @param {restaurantaddressUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Restaurantaddresses
   * const restaurantaddress = await prisma.restaurantaddress.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends restaurantaddressUpdateManyArgs>(
    args: Subset<T, restaurantaddressUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Restaurantaddress.
   * @param {restaurantaddressUpsertArgs} args - Arguments to update or create a Restaurantaddress.
   * @example
   * // Update or create a Restaurantaddress
   * const restaurantaddress = await prisma.restaurantaddress.upsert({
   *   create: {
   *     // ... data to create a Restaurantaddress
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Restaurantaddress we want to update
   *   }
   * })
  **/
  upsert<T extends restaurantaddressUpsertArgs>(
    args: Subset<T, restaurantaddressUpsertArgs>
  ): CheckSelect<T, Prisma__restaurantaddressClient<restaurantaddress>, Prisma__restaurantaddressClient<restaurantaddressGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyrestaurantaddressArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateRestaurantaddressArgs>(args: Subset<T, AggregateRestaurantaddressArgs>): Promise<GetRestaurantaddressAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for restaurantaddress.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__restaurantaddressClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  restaurant<T extends FindManyrestaurantArgs = {}>(args?: Subset<T, FindManyrestaurantArgs>): CheckSelect<T, Promise<Array<restaurant>>, Promise<Array<restaurantGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * restaurantaddress findOne
 */
export type FindOnerestaurantaddressArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
  /**
   * Filter, which restaurantaddress to fetch.
  **/
  where: restaurantaddressWhereUniqueInput
}


/**
 * restaurantaddress findMany
 */
export type FindManyrestaurantaddressArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
  /**
   * Filter, which restaurantaddresses to fetch.
  **/
  where?: restaurantaddressWhereInput
  /**
   * Determine the order of the restaurantaddresses to fetch.
  **/
  orderBy?: Enumerable<restaurantaddressOrderByInput>
  /**
   * Sets the position for listing restaurantaddresses.
  **/
  cursor?: restaurantaddressWhereUniqueInput
  /**
   * The number of restaurantaddresses to fetch. If negative number, it will take restaurantaddresses before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` restaurantaddresses.
  **/
  skip?: number
  distinct?: Enumerable<RestaurantaddressDistinctFieldEnum>
}


/**
 * restaurantaddress create
 */
export type restaurantaddressCreateArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
  /**
   * The data needed to create a restaurantaddress.
  **/
  data: restaurantaddressCreateInput
}


/**
 * restaurantaddress update
 */
export type restaurantaddressUpdateArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
  /**
   * The data needed to update a restaurantaddress.
  **/
  data: restaurantaddressUpdateInput
  /**
   * Choose, which restaurantaddress to update.
  **/
  where: restaurantaddressWhereUniqueInput
}


/**
 * restaurantaddress updateMany
 */
export type restaurantaddressUpdateManyArgs = {
  data: restaurantaddressUpdateManyMutationInput
  where?: restaurantaddressWhereInput
}


/**
 * restaurantaddress upsert
 */
export type restaurantaddressUpsertArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
  /**
   * The filter to search for the restaurantaddress to update in case it exists.
  **/
  where: restaurantaddressWhereUniqueInput
  /**
   * In case the restaurantaddress found by the `where` argument doesn't exist, create a new restaurantaddress with this data.
  **/
  create: restaurantaddressCreateInput
  /**
   * In case the restaurantaddress was found with the provided `where` argument, update it with this data.
  **/
  update: restaurantaddressUpdateInput
}


/**
 * restaurantaddress delete
 */
export type restaurantaddressDeleteArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
  /**
   * Filter which restaurantaddress to delete.
  **/
  where: restaurantaddressWhereUniqueInput
}


/**
 * restaurantaddress deleteMany
 */
export type restaurantaddressDeleteManyArgs = {
  where?: restaurantaddressWhereInput
}


/**
 * restaurantaddress without action
 */
export type restaurantaddressArgs = {
  /**
   * Select specific fields to fetch from the restaurantaddress
  **/
  select?: restaurantaddressSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: restaurantaddressInclude | null
}



/**
 * Model review
 */

export type review = {
  id: number
  title: string
  description: string
  rating: number | null
  user_id: number | null
  restaurant_id: number
}


export type AggregateReview = {
  count: number
  avg: ReviewAvgAggregateOutputType | null
  sum: ReviewSumAggregateOutputType | null
  min: ReviewMinAggregateOutputType | null
  max: ReviewMaxAggregateOutputType | null
}

export type ReviewAvgAggregateOutputType = {
  id: number
  rating: number
  user_id: number
  restaurant_id: number
}

export type ReviewSumAggregateOutputType = {
  id: number
  rating: number | null
  user_id: number | null
  restaurant_id: number
}

export type ReviewMinAggregateOutputType = {
  id: number
  rating: number | null
  user_id: number | null
  restaurant_id: number
}

export type ReviewMaxAggregateOutputType = {
  id: number
  rating: number | null
  user_id: number | null
  restaurant_id: number
}


export type ReviewAvgAggregateInputType = {
  id?: true
  rating?: true
  user_id?: true
  restaurant_id?: true
}

export type ReviewSumAggregateInputType = {
  id?: true
  rating?: true
  user_id?: true
  restaurant_id?: true
}

export type ReviewMinAggregateInputType = {
  id?: true
  rating?: true
  user_id?: true
  restaurant_id?: true
}

export type ReviewMaxAggregateInputType = {
  id?: true
  rating?: true
  user_id?: true
  restaurant_id?: true
}

export type AggregateReviewArgs = {
  where?: reviewWhereInput
  orderBy?: Enumerable<reviewOrderByInput>
  cursor?: reviewWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ReviewDistinctFieldEnum>
  count?: true
  avg?: ReviewAvgAggregateInputType
  sum?: ReviewSumAggregateInputType
  min?: ReviewMinAggregateInputType
  max?: ReviewMaxAggregateInputType
}

export type GetReviewAggregateType<T extends AggregateReviewArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetReviewAggregateScalarType<T[P]>
}

export type GetReviewAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ReviewAvgAggregateOutputType ? ReviewAvgAggregateOutputType[P] : never
}
    
    

export type reviewSelect = {
  id?: boolean
  title?: boolean
  description?: boolean
  rating?: boolean
  user_id?: boolean
  restaurant_id?: boolean
  restaurant?: boolean | restaurantArgs
  user?: boolean | userArgs
}

export type reviewInclude = {
  restaurant?: boolean | restaurantArgs
  user?: boolean | userArgs
}

export type reviewGetPayload<
  S extends boolean | null | undefined | reviewArgs,
  U = keyof S
> = S extends true
  ? review
  : S extends undefined
  ? never
  : S extends reviewArgs | FindManyreviewArgs
  ? 'include' extends U
    ? review  & {
      [P in TrueKeys<S['include']>]:
      P extends 'restaurant'
      ? restaurantGetPayload<S['include'][P]> :
      P extends 'user'
      ? userGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof review ? review[P]
: 
      P extends 'restaurant'
      ? restaurantGetPayload<S['select'][P]> :
      P extends 'user'
      ? userGetPayload<S['select'][P]> | null : never
    }
  : review
: review


export interface reviewDelegate {
  /**
   * Find zero or one Review.
   * @param {FindOnereviewArgs} args - Arguments to find a Review
   * @example
   * // Get one Review
   * const review = await prisma.review.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnereviewArgs>(
    args: Subset<T, FindOnereviewArgs>
  ): CheckSelect<T, Prisma__reviewClient<review | null>, Prisma__reviewClient<reviewGetPayload<T> | null>>
  /**
   * Find zero or more Reviews.
   * @param {FindManyreviewArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Reviews
   * const reviews = await prisma.review.findMany()
   * 
   * // Get first 10 Reviews
   * const reviews = await prisma.review.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyreviewArgs>(
    args?: Subset<T, FindManyreviewArgs>
  ): CheckSelect<T, Promise<Array<review>>, Promise<Array<reviewGetPayload<T>>>>
  /**
   * Create a Review.
   * @param {reviewCreateArgs} args - Arguments to create a Review.
   * @example
   * // Create one Review
   * const Review = await prisma.review.create({
   *   data: {
   *     // ... data to create a Review
   *   }
   * })
   * 
  **/
  create<T extends reviewCreateArgs>(
    args: Subset<T, reviewCreateArgs>
  ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>
  /**
   * Delete a Review.
   * @param {reviewDeleteArgs} args - Arguments to delete one Review.
   * @example
   * // Delete one Review
   * const Review = await prisma.review.delete({
   *   where: {
   *     // ... filter to delete one Review
   *   }
   * })
   * 
  **/
  delete<T extends reviewDeleteArgs>(
    args: Subset<T, reviewDeleteArgs>
  ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>
  /**
   * Update one Review.
   * @param {reviewUpdateArgs} args - Arguments to update one Review.
   * @example
   * // Update one Review
   * const review = await prisma.review.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends reviewUpdateArgs>(
    args: Subset<T, reviewUpdateArgs>
  ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>
  /**
   * Delete zero or more Reviews.
   * @param {reviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
   * @example
   * // Delete a few Reviews
   * const { count } = await prisma.review.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends reviewDeleteManyArgs>(
    args: Subset<T, reviewDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Reviews.
   * @param {reviewUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Reviews
   * const review = await prisma.review.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends reviewUpdateManyArgs>(
    args: Subset<T, reviewUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Review.
   * @param {reviewUpsertArgs} args - Arguments to update or create a Review.
   * @example
   * // Update or create a Review
   * const review = await prisma.review.upsert({
   *   create: {
   *     // ... data to create a Review
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Review we want to update
   *   }
   * })
  **/
  upsert<T extends reviewUpsertArgs>(
    args: Subset<T, reviewUpsertArgs>
  ): CheckSelect<T, Prisma__reviewClient<review>, Prisma__reviewClient<reviewGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyreviewArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateReviewArgs>(args: Subset<T, AggregateReviewArgs>): Promise<GetReviewAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for review.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__reviewClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  restaurant<T extends restaurantArgs = {}>(args?: Subset<T, restaurantArgs>): CheckSelect<T, Prisma__restaurantClient<restaurant | null>, Prisma__restaurantClient<restaurantGetPayload<T> | null>>;

  user<T extends userArgs = {}>(args?: Subset<T, userArgs>): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * review findOne
 */
export type FindOnereviewArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * Filter, which review to fetch.
  **/
  where: reviewWhereUniqueInput
}


/**
 * review findMany
 */
export type FindManyreviewArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * Filter, which reviews to fetch.
  **/
  where?: reviewWhereInput
  /**
   * Determine the order of the reviews to fetch.
  **/
  orderBy?: Enumerable<reviewOrderByInput>
  /**
   * Sets the position for listing reviews.
  **/
  cursor?: reviewWhereUniqueInput
  /**
   * The number of reviews to fetch. If negative number, it will take reviews before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` reviews.
  **/
  skip?: number
  distinct?: Enumerable<ReviewDistinctFieldEnum>
}


/**
 * review create
 */
export type reviewCreateArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * The data needed to create a review.
  **/
  data: reviewCreateInput
}


/**
 * review update
 */
export type reviewUpdateArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * The data needed to update a review.
  **/
  data: reviewUpdateInput
  /**
   * Choose, which review to update.
  **/
  where: reviewWhereUniqueInput
}


/**
 * review updateMany
 */
export type reviewUpdateManyArgs = {
  data: reviewUpdateManyMutationInput
  where?: reviewWhereInput
}


/**
 * review upsert
 */
export type reviewUpsertArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * The filter to search for the review to update in case it exists.
  **/
  where: reviewWhereUniqueInput
  /**
   * In case the review found by the `where` argument doesn't exist, create a new review with this data.
  **/
  create: reviewCreateInput
  /**
   * In case the review was found with the provided `where` argument, update it with this data.
  **/
  update: reviewUpdateInput
}


/**
 * review delete
 */
export type reviewDeleteArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
  /**
   * Filter which review to delete.
  **/
  where: reviewWhereUniqueInput
}


/**
 * review deleteMany
 */
export type reviewDeleteManyArgs = {
  where?: reviewWhereInput
}


/**
 * review without action
 */
export type reviewArgs = {
  /**
   * Select specific fields to fetch from the review
  **/
  select?: reviewSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: reviewInclude | null
}



/**
 * Model status
 */

export type status = {
  id: number
  code: string
  description: string
}


export type AggregateStatus = {
  count: number
  avg: StatusAvgAggregateOutputType | null
  sum: StatusSumAggregateOutputType | null
  min: StatusMinAggregateOutputType | null
  max: StatusMaxAggregateOutputType | null
}

export type StatusAvgAggregateOutputType = {
  id: number
}

export type StatusSumAggregateOutputType = {
  id: number
}

export type StatusMinAggregateOutputType = {
  id: number
}

export type StatusMaxAggregateOutputType = {
  id: number
}


export type StatusAvgAggregateInputType = {
  id?: true
}

export type StatusSumAggregateInputType = {
  id?: true
}

export type StatusMinAggregateInputType = {
  id?: true
}

export type StatusMaxAggregateInputType = {
  id?: true
}

export type AggregateStatusArgs = {
  where?: statusWhereInput
  orderBy?: Enumerable<statusOrderByInput>
  cursor?: statusWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<StatusDistinctFieldEnum>
  count?: true
  avg?: StatusAvgAggregateInputType
  sum?: StatusSumAggregateInputType
  min?: StatusMinAggregateInputType
  max?: StatusMaxAggregateInputType
}

export type GetStatusAggregateType<T extends AggregateStatusArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetStatusAggregateScalarType<T[P]>
}

export type GetStatusAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof StatusAvgAggregateOutputType ? StatusAvgAggregateOutputType[P] : never
}
    
    

export type statusSelect = {
  id?: boolean
  code?: boolean
  description?: boolean
  order?: boolean | FindManyorderArgs
}

export type statusInclude = {
  order?: boolean | FindManyorderArgs
}

export type statusGetPayload<
  S extends boolean | null | undefined | statusArgs,
  U = keyof S
> = S extends true
  ? status
  : S extends undefined
  ? never
  : S extends statusArgs | FindManystatusArgs
  ? 'include' extends U
    ? status  & {
      [P in TrueKeys<S['include']>]:
      P extends 'order'
      ? Array<orderGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof status ? status[P]
: 
      P extends 'order'
      ? Array<orderGetPayload<S['select'][P]>> : never
    }
  : status
: status


export interface statusDelegate {
  /**
   * Find zero or one Status.
   * @param {FindOnestatusArgs} args - Arguments to find a Status
   * @example
   * // Get one Status
   * const status = await prisma.status.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnestatusArgs>(
    args: Subset<T, FindOnestatusArgs>
  ): CheckSelect<T, Prisma__statusClient<status | null>, Prisma__statusClient<statusGetPayload<T> | null>>
  /**
   * Find zero or more Statuses.
   * @param {FindManystatusArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Statuses
   * const statuses = await prisma.status.findMany()
   * 
   * // Get first 10 Statuses
   * const statuses = await prisma.status.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const statusWithIdOnly = await prisma.status.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManystatusArgs>(
    args?: Subset<T, FindManystatusArgs>
  ): CheckSelect<T, Promise<Array<status>>, Promise<Array<statusGetPayload<T>>>>
  /**
   * Create a Status.
   * @param {statusCreateArgs} args - Arguments to create a Status.
   * @example
   * // Create one Status
   * const Status = await prisma.status.create({
   *   data: {
   *     // ... data to create a Status
   *   }
   * })
   * 
  **/
  create<T extends statusCreateArgs>(
    args: Subset<T, statusCreateArgs>
  ): CheckSelect<T, Prisma__statusClient<status>, Prisma__statusClient<statusGetPayload<T>>>
  /**
   * Delete a Status.
   * @param {statusDeleteArgs} args - Arguments to delete one Status.
   * @example
   * // Delete one Status
   * const Status = await prisma.status.delete({
   *   where: {
   *     // ... filter to delete one Status
   *   }
   * })
   * 
  **/
  delete<T extends statusDeleteArgs>(
    args: Subset<T, statusDeleteArgs>
  ): CheckSelect<T, Prisma__statusClient<status>, Prisma__statusClient<statusGetPayload<T>>>
  /**
   * Update one Status.
   * @param {statusUpdateArgs} args - Arguments to update one Status.
   * @example
   * // Update one Status
   * const status = await prisma.status.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends statusUpdateArgs>(
    args: Subset<T, statusUpdateArgs>
  ): CheckSelect<T, Prisma__statusClient<status>, Prisma__statusClient<statusGetPayload<T>>>
  /**
   * Delete zero or more Statuses.
   * @param {statusDeleteManyArgs} args - Arguments to filter Statuses to delete.
   * @example
   * // Delete a few Statuses
   * const { count } = await prisma.status.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends statusDeleteManyArgs>(
    args: Subset<T, statusDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Statuses.
   * @param {statusUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Statuses
   * const status = await prisma.status.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends statusUpdateManyArgs>(
    args: Subset<T, statusUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Status.
   * @param {statusUpsertArgs} args - Arguments to update or create a Status.
   * @example
   * // Update or create a Status
   * const status = await prisma.status.upsert({
   *   create: {
   *     // ... data to create a Status
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Status we want to update
   *   }
   * })
  **/
  upsert<T extends statusUpsertArgs>(
    args: Subset<T, statusUpsertArgs>
  ): CheckSelect<T, Prisma__statusClient<status>, Prisma__statusClient<statusGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManystatusArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateStatusArgs>(args: Subset<T, AggregateStatusArgs>): Promise<GetStatusAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for status.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__statusClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  order<T extends FindManyorderArgs = {}>(args?: Subset<T, FindManyorderArgs>): CheckSelect<T, Promise<Array<order>>, Promise<Array<orderGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * status findOne
 */
export type FindOnestatusArgs = {
  /**
   * Select specific fields to fetch from the status
  **/
  select?: statusSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: statusInclude | null
  /**
   * Filter, which status to fetch.
  **/
  where: statusWhereUniqueInput
}


/**
 * status findMany
 */
export type FindManystatusArgs = {
  /**
   * Select specific fields to fetch from the status
  **/
  select?: statusSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: statusInclude | null
  /**
   * Filter, which statuses to fetch.
  **/
  where?: statusWhereInput
  /**
   * Determine the order of the statuses to fetch.
  **/
  orderBy?: Enumerable<statusOrderByInput>
  /**
   * Sets the position for listing statuses.
  **/
  cursor?: statusWhereUniqueInput
  /**
   * The number of statuses to fetch. If negative number, it will take statuses before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` statuses.
  **/
  skip?: number
  distinct?: Enumerable<StatusDistinctFieldEnum>
}


/**
 * status create
 */
export type statusCreateArgs = {
  /**
   * Select specific fields to fetch from the status
  **/
  select?: statusSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: statusInclude | null
  /**
   * The data needed to create a status.
  **/
  data: statusCreateInput
}


/**
 * status update
 */
export type statusUpdateArgs = {
  /**
   * Select specific fields to fetch from the status
  **/
  select?: statusSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: statusInclude | null
  /**
   * The data needed to update a status.
  **/
  data: statusUpdateInput
  /**
   * Choose, which status to update.
  **/
  where: statusWhereUniqueInput
}


/**
 * status updateMany
 */
export type statusUpdateManyArgs = {
  data: statusUpdateManyMutationInput
  where?: statusWhereInput
}


/**
 * status upsert
 */
export type statusUpsertArgs = {
  /**
   * Select specific fields to fetch from the status
  **/
  select?: statusSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: statusInclude | null
  /**
   * The filter to search for the status to update in case it exists.
  **/
  where: statusWhereUniqueInput
  /**
   * In case the status found by the `where` argument doesn't exist, create a new status with this data.
  **/
  create: statusCreateInput
  /**
   * In case the status was found with the provided `where` argument, update it with this data.
  **/
  update: statusUpdateInput
}


/**
 * status delete
 */
export type statusDeleteArgs = {
  /**
   * Select specific fields to fetch from the status
  **/
  select?: statusSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: statusInclude | null
  /**
   * Filter which status to delete.
  **/
  where: statusWhereUniqueInput
}


/**
 * status deleteMany
 */
export type statusDeleteManyArgs = {
  where?: statusWhereInput
}


/**
 * status without action
 */
export type statusArgs = {
  /**
   * Select specific fields to fetch from the status
  **/
  select?: statusSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: statusInclude | null
}



/**
 * Model user
 */

export type user = {
  id: number
  firstname: string
  lastname: string
  password: string
  email: string
  role: string | null
}


export type AggregateUser = {
  count: number
  avg: UserAvgAggregateOutputType | null
  sum: UserSumAggregateOutputType | null
  min: UserMinAggregateOutputType | null
  max: UserMaxAggregateOutputType | null
}

export type UserAvgAggregateOutputType = {
  id: number
}

export type UserSumAggregateOutputType = {
  id: number
}

export type UserMinAggregateOutputType = {
  id: number
}

export type UserMaxAggregateOutputType = {
  id: number
}


export type UserAvgAggregateInputType = {
  id?: true
}

export type UserSumAggregateInputType = {
  id?: true
}

export type UserMinAggregateInputType = {
  id?: true
}

export type UserMaxAggregateInputType = {
  id?: true
}

export type AggregateUserArgs = {
  where?: userWhereInput
  orderBy?: Enumerable<userOrderByInput>
  cursor?: userWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
  count?: true
  avg?: UserAvgAggregateInputType
  sum?: UserSumAggregateInputType
  min?: UserMinAggregateInputType
  max?: UserMaxAggregateInputType
}

export type GetUserAggregateType<T extends AggregateUserArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetUserAggregateScalarType<T[P]>
}

export type GetUserAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof UserAvgAggregateOutputType ? UserAvgAggregateOutputType[P] : never
}
    
    

export type userSelect = {
  id?: boolean
  firstname?: boolean
  lastname?: boolean
  password?: boolean
  email?: boolean
  role?: boolean
  address?: boolean | FindManyaddressArgs
  order?: boolean | FindManyorderArgs
  owneraccount?: boolean | FindManyowneraccountArgs
  restaurant?: boolean | FindManyrestaurantArgs
  review?: boolean | FindManyreviewArgs
}

export type userInclude = {
  address?: boolean | FindManyaddressArgs
  order?: boolean | FindManyorderArgs
  owneraccount?: boolean | FindManyowneraccountArgs
  restaurant?: boolean | FindManyrestaurantArgs
  review?: boolean | FindManyreviewArgs
}

export type userGetPayload<
  S extends boolean | null | undefined | userArgs,
  U = keyof S
> = S extends true
  ? user
  : S extends undefined
  ? never
  : S extends userArgs | FindManyuserArgs
  ? 'include' extends U
    ? user  & {
      [P in TrueKeys<S['include']>]:
      P extends 'address'
      ? Array<addressGetPayload<S['include'][P]>> :
      P extends 'order'
      ? Array<orderGetPayload<S['include'][P]>> :
      P extends 'owneraccount'
      ? Array<owneraccountGetPayload<S['include'][P]>> :
      P extends 'restaurant'
      ? Array<restaurantGetPayload<S['include'][P]>> :
      P extends 'review'
      ? Array<reviewGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof user ? user[P]
: 
      P extends 'address'
      ? Array<addressGetPayload<S['select'][P]>> :
      P extends 'order'
      ? Array<orderGetPayload<S['select'][P]>> :
      P extends 'owneraccount'
      ? Array<owneraccountGetPayload<S['select'][P]>> :
      P extends 'restaurant'
      ? Array<restaurantGetPayload<S['select'][P]>> :
      P extends 'review'
      ? Array<reviewGetPayload<S['select'][P]>> : never
    }
  : user
: user


export interface userDelegate {
  /**
   * Find zero or one User.
   * @param {FindOneuserArgs} args - Arguments to find a User
   * @example
   * // Get one User
   * const user = await prisma.user.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneuserArgs>(
    args: Subset<T, FindOneuserArgs>
  ): CheckSelect<T, Prisma__userClient<user | null>, Prisma__userClient<userGetPayload<T> | null>>
  /**
   * Find zero or more Users.
   * @param {FindManyuserArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Users
   * const users = await prisma.user.findMany()
   * 
   * // Get first 10 Users
   * const users = await prisma.user.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyuserArgs>(
    args?: Subset<T, FindManyuserArgs>
  ): CheckSelect<T, Promise<Array<user>>, Promise<Array<userGetPayload<T>>>>
  /**
   * Create a User.
   * @param {userCreateArgs} args - Arguments to create a User.
   * @example
   * // Create one User
   * const User = await prisma.user.create({
   *   data: {
   *     // ... data to create a User
   *   }
   * })
   * 
  **/
  create<T extends userCreateArgs>(
    args: Subset<T, userCreateArgs>
  ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>
  /**
   * Delete a User.
   * @param {userDeleteArgs} args - Arguments to delete one User.
   * @example
   * // Delete one User
   * const User = await prisma.user.delete({
   *   where: {
   *     // ... filter to delete one User
   *   }
   * })
   * 
  **/
  delete<T extends userDeleteArgs>(
    args: Subset<T, userDeleteArgs>
  ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>
  /**
   * Update one User.
   * @param {userUpdateArgs} args - Arguments to update one User.
   * @example
   * // Update one User
   * const user = await prisma.user.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends userUpdateArgs>(
    args: Subset<T, userUpdateArgs>
  ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>
  /**
   * Delete zero or more Users.
   * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
   * @example
   * // Delete a few Users
   * const { count } = await prisma.user.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends userDeleteManyArgs>(
    args: Subset<T, userDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Users.
   * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Users
   * const user = await prisma.user.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends userUpdateManyArgs>(
    args: Subset<T, userUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one User.
   * @param {userUpsertArgs} args - Arguments to update or create a User.
   * @example
   * // Update or create a User
   * const user = await prisma.user.upsert({
   *   create: {
   *     // ... data to create a User
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the User we want to update
   *   }
   * })
  **/
  upsert<T extends userUpsertArgs>(
    args: Subset<T, userUpsertArgs>
  ): CheckSelect<T, Prisma__userClient<user>, Prisma__userClient<userGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyuserArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateUserArgs>(args: Subset<T, AggregateUserArgs>): Promise<GetUserAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for user.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__userClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  address<T extends FindManyaddressArgs = {}>(args?: Subset<T, FindManyaddressArgs>): CheckSelect<T, Promise<Array<address>>, Promise<Array<addressGetPayload<T>>>>;

  order<T extends FindManyorderArgs = {}>(args?: Subset<T, FindManyorderArgs>): CheckSelect<T, Promise<Array<order>>, Promise<Array<orderGetPayload<T>>>>;

  owneraccount<T extends FindManyowneraccountArgs = {}>(args?: Subset<T, FindManyowneraccountArgs>): CheckSelect<T, Promise<Array<owneraccount>>, Promise<Array<owneraccountGetPayload<T>>>>;

  restaurant<T extends FindManyrestaurantArgs = {}>(args?: Subset<T, FindManyrestaurantArgs>): CheckSelect<T, Promise<Array<restaurant>>, Promise<Array<restaurantGetPayload<T>>>>;

  review<T extends FindManyreviewArgs = {}>(args?: Subset<T, FindManyreviewArgs>): CheckSelect<T, Promise<Array<review>>, Promise<Array<reviewGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * user findOne
 */
export type FindOneuserArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
  /**
   * Filter, which user to fetch.
  **/
  where: userWhereUniqueInput
}


/**
 * user findMany
 */
export type FindManyuserArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
  /**
   * Filter, which users to fetch.
  **/
  where?: userWhereInput
  /**
   * Determine the order of the users to fetch.
  **/
  orderBy?: Enumerable<userOrderByInput>
  /**
   * Sets the position for listing users.
  **/
  cursor?: userWhereUniqueInput
  /**
   * The number of users to fetch. If negative number, it will take users before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` users.
  **/
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}


/**
 * user create
 */
export type userCreateArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
  /**
   * The data needed to create a user.
  **/
  data: userCreateInput
}


/**
 * user update
 */
export type userUpdateArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
  /**
   * The data needed to update a user.
  **/
  data: userUpdateInput
  /**
   * Choose, which user to update.
  **/
  where: userWhereUniqueInput
}


/**
 * user updateMany
 */
export type userUpdateManyArgs = {
  data: userUpdateManyMutationInput
  where?: userWhereInput
}


/**
 * user upsert
 */
export type userUpsertArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
  /**
   * The filter to search for the user to update in case it exists.
  **/
  where: userWhereUniqueInput
  /**
   * In case the user found by the `where` argument doesn't exist, create a new user with this data.
  **/
  create: userCreateInput
  /**
   * In case the user was found with the provided `where` argument, update it with this data.
  **/
  update: userUpdateInput
}


/**
 * user delete
 */
export type userDeleteArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
  /**
   * Filter which user to delete.
  **/
  where: userWhereUniqueInput
}


/**
 * user deleteMany
 */
export type userDeleteManyArgs = {
  where?: userWhereInput
}


/**
 * user without action
 */
export type userArgs = {
  /**
   * Select specific fields to fetch from the user
  **/
  select?: userSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: userInclude | null
}



/**
 * Deep Input Types
 */


export type NestedIntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: NestedIntFilter | null
}

export type IntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntFilter
}

export type NestedStringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: NestedStringFilter | null
}

export type StringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringFilter
}

export type NestedIntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
  not?: NestedIntNullableFilter | null
}

export type IntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
  not?: number | NestedIntNullableFilter | null
}

export type NestedStringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
  not?: NestedStringNullableFilter | null
}

export type StringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
  not?: string | NestedStringNullableFilter | null
}

export type AddressListRelationFilter = {
  every?: addressWhereInput
  some?: addressWhereInput
  none?: addressWhereInput
}

export type NestedDateTimeFilter = {
  equals?: Date | string
  in?: Enumerable<Date | string>
  notIn?: Enumerable<Date | string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: NestedDateTimeFilter | null
}

export type DateTimeFilter = {
  equals?: Date | string
  in?: Enumerable<Date | string>
  notIn?: Enumerable<Date | string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: Date | string | NestedDateTimeFilter
}

export type NestedFloatFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: NestedFloatFilter | null
}

export type FloatFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatFilter
}

export type AddressRelationFilter = {
  is?: addressWhereInput | null
  isNot?: addressWhereInput | null
}

export type statusWhereInput = {
  AND?: Enumerable<statusWhereInput>
  OR?: Array<statusWhereInput>
  NOT?: Enumerable<statusWhereInput>
  id?: number | IntFilter
  code?: string | StringFilter
  description?: string | StringFilter
  order?: OrderListRelationFilter
}

export type StatusRelationFilter = {
  is?: statusWhereInput | null
  isNot?: statusWhereInput | null
}

export type StringNullableListFilter = {
  equals?: Enumerable<string>
}

export type NestedJsonNullableFilter = {
  equals?: InputJsonValue | null
  not?: NestedJsonNullableFilter | null
}

export type JsonNullableFilter = {
  equals?: InputJsonValue | null
  not?: InputJsonValue | NestedJsonNullableFilter | null
}

export type RestaurantListRelationFilter = {
  every?: restaurantWhereInput
  some?: restaurantWhereInput
  none?: restaurantWhereInput
}

export type restaurantaddressWhereInput = {
  AND?: Enumerable<restaurantaddressWhereInput>
  OR?: Array<restaurantaddressWhereInput>
  NOT?: Enumerable<restaurantaddressWhereInput>
  id?: number | IntFilter
  city?: string | StringFilter
  street?: string | StringFilter
  zip?: string | StringFilter
  restaurant?: RestaurantListRelationFilter
}

export type RestaurantaddressRelationFilter = {
  is?: restaurantaddressWhereInput | null
  isNot?: restaurantaddressWhereInput | null
}

export type DishListRelationFilter = {
  every?: dishWhereInput
  some?: dishWhereInput
  none?: dishWhereInput
}

export type reviewWhereInput = {
  AND?: Enumerable<reviewWhereInput>
  OR?: Array<reviewWhereInput>
  NOT?: Enumerable<reviewWhereInput>
  id?: number | IntFilter
  title?: string | StringFilter
  description?: string | StringFilter
  rating?: number | IntNullableFilter | null
  user_id?: number | IntNullableFilter | null
  restaurant_id?: number | IntFilter
  restaurant?: restaurantWhereInput | null
  user?: userWhereInput | null
}

export type ReviewListRelationFilter = {
  every?: reviewWhereInput
  some?: reviewWhereInput
  none?: reviewWhereInput
}

export type restaurantWhereInput = {
  AND?: Enumerable<restaurantWhereInput>
  OR?: Array<restaurantWhereInput>
  NOT?: Enumerable<restaurantWhereInput>
  id?: number | IntFilter
  name?: string | StringFilter
  type?: string | StringFilter
  phone?: string | StringFilter
  delivery?: number | IntFilter
  deliveryfee?: number | IntFilter
  owner_id?: number | IntFilter
  address_id?: number | IntFilter
  restaurantaddress?: restaurantaddressWhereInput | null
  user?: userWhereInput | null
  dish?: DishListRelationFilter
  review?: ReviewListRelationFilter
}

export type RestaurantRelationFilter = {
  is?: restaurantWhereInput | null
  isNot?: restaurantWhereInput | null
}

export type dishWhereInput = {
  AND?: Enumerable<dishWhereInput>
  OR?: Array<dishWhereInput>
  NOT?: Enumerable<dishWhereInput>
  id?: number | IntFilter
  name?: string | StringFilter
  sizes?: Enumerable<string | StringNullableListFilter>
  ingredients?: Enumerable<string | StringNullableListFilter>
  price?: number | FloatFilter
  restaurant_id?: number | IntFilter
  ingredientchoice?: InputJsonValue | JsonNullableFilter | null
  additions?: InputJsonValue | JsonNullableFilter | null
  restaurant?: restaurantWhereInput | null
  orderitem?: OrderitemListRelationFilter
}

export type DishRelationFilter = {
  is?: dishWhereInput | null
  isNot?: dishWhereInput | null
}

export type OrderRelationFilter = {
  is?: orderWhereInput | null
  isNot?: orderWhereInput | null
}

export type orderitemWhereInput = {
  AND?: Enumerable<orderitemWhereInput>
  OR?: Array<orderitemWhereInput>
  NOT?: Enumerable<orderitemWhereInput>
  id?: number | IntFilter
  quantity?: number | IntFilter
  item_id?: number | IntFilter
  order_id?: number | IntFilter
  dish?: dishWhereInput | null
  order?: orderWhereInput | null
}

export type OrderitemListRelationFilter = {
  every?: orderitemWhereInput
  some?: orderitemWhereInput
  none?: orderitemWhereInput
}

export type orderWhereInput = {
  AND?: Enumerable<orderWhereInput>
  OR?: Array<orderWhereInput>
  NOT?: Enumerable<orderWhereInput>
  id?: number | IntFilter
  user_id?: number | IntFilter
  date?: Date | string | DateTimeFilter
  status_id?: number | IntFilter
  quantity?: number | IntFilter
  amount?: number | FloatFilter
  address_id?: number | IntFilter
  phone?: string | StringFilter
  address?: addressWhereInput | null
  status?: statusWhereInput | null
  user?: userWhereInput | null
  orderitem?: OrderitemListRelationFilter
}

export type OrderListRelationFilter = {
  every?: orderWhereInput
  some?: orderWhereInput
  none?: orderWhereInput
}

export type owneraccountWhereInput = {
  AND?: Enumerable<owneraccountWhereInput>
  OR?: Array<owneraccountWhereInput>
  NOT?: Enumerable<owneraccountWhereInput>
  id?: number | IntFilter
  client_id?: number | IntNullableFilter | null
  user?: userWhereInput | null
}

export type OwneraccountListRelationFilter = {
  every?: owneraccountWhereInput
  some?: owneraccountWhereInput
  none?: owneraccountWhereInput
}

export type userWhereInput = {
  AND?: Enumerable<userWhereInput>
  OR?: Array<userWhereInput>
  NOT?: Enumerable<userWhereInput>
  id?: number | IntFilter
  firstname?: string | StringFilter
  lastname?: string | StringFilter
  password?: string | StringFilter
  email?: string | StringFilter
  role?: string | StringNullableFilter | null
  address?: AddressListRelationFilter
  order?: OrderListRelationFilter
  owneraccount?: OwneraccountListRelationFilter
  restaurant?: RestaurantListRelationFilter
  review?: ReviewListRelationFilter
}

export type UserRelationFilter = {
  is?: userWhereInput | null
  isNot?: userWhereInput | null
}

export type addressWhereInput = {
  AND?: Enumerable<addressWhereInput>
  OR?: Array<addressWhereInput>
  NOT?: Enumerable<addressWhereInput>
  id?: number | IntFilter
  city?: string | StringFilter
  street?: string | StringFilter
  zip?: string | StringFilter
  user_id?: number | IntNullableFilter | null
  user?: userWhereInput | null
  order?: OrderListRelationFilter
}

export type addressOrderByInput = {
  id?: SortOrder
  city?: SortOrder
  street?: SortOrder
  zip?: SortOrder
  user_id?: SortOrder
}

export type addressWhereUniqueInput = {
  id?: number
}

export type orderOrderByInput = {
  id?: SortOrder
  user_id?: SortOrder
  date?: SortOrder
  status_id?: SortOrder
  quantity?: SortOrder
  amount?: SortOrder
  address_id?: SortOrder
  phone?: SortOrder
}

export type orderWhereUniqueInput = {
  id?: number
}

export type orderitemOrderByInput = {
  id?: SortOrder
  quantity?: SortOrder
  item_id?: SortOrder
  order_id?: SortOrder
}

export type orderitemWhereUniqueInput = {
  id?: number
}

export type restaurantOrderByInput = {
  id?: SortOrder
  name?: SortOrder
  type?: SortOrder
  phone?: SortOrder
  delivery?: SortOrder
  deliveryfee?: SortOrder
  owner_id?: SortOrder
  address_id?: SortOrder
}

export type restaurantWhereUniqueInput = {
  id?: number
}

export type dishOrderByInput = {
  id?: SortOrder
  name?: SortOrder
  sizes?: SortOrder
  ingredients?: SortOrder
  price?: SortOrder
  restaurant_id?: SortOrder
  ingredientchoice?: SortOrder
  additions?: SortOrder
}

export type dishWhereUniqueInput = {
  id?: number
}

export type reviewOrderByInput = {
  id?: SortOrder
  title?: SortOrder
  description?: SortOrder
  rating?: SortOrder
  user_id?: SortOrder
  restaurant_id?: SortOrder
}

export type reviewWhereUniqueInput = {
  id?: number
}

export type owneraccountOrderByInput = {
  id?: SortOrder
  client_id?: SortOrder
}

export type owneraccountWhereUniqueInput = {
  id?: number
}

export type restaurantaddressOrderByInput = {
  id?: SortOrder
  city?: SortOrder
  street?: SortOrder
  zip?: SortOrder
}

export type restaurantaddressWhereUniqueInput = {
  id?: number
}

export type statusOrderByInput = {
  id?: SortOrder
  code?: SortOrder
  description?: SortOrder
}

export type statusWhereUniqueInput = {
  id?: number
}

export type userOrderByInput = {
  id?: SortOrder
  firstname?: SortOrder
  lastname?: SortOrder
  password?: SortOrder
  email?: SortOrder
  role?: SortOrder
}

export type userWhereUniqueInput = {
  id?: number
  email?: string
}

export type addressCreateWithoutOrderInput = {
  city: string
  street: string
  zip: string
  user?: userCreateOneWithoutAddressInput
}

export type addressCreateOneWithoutOrderInput = {
  create?: addressCreateWithoutOrderInput
  connect?: addressWhereUniqueInput
}

export type statusCreateWithoutOrderInput = {
  code: string
  description: string
}

export type statusCreateOneWithoutOrderInput = {
  create?: statusCreateWithoutOrderInput
  connect?: statusWhereUniqueInput
}

export type dishCreatesizesInput = {
  set?: Enumerable<string>
}

export type dishCreateingredientsInput = {
  set?: Enumerable<string>
}

export type restaurantaddressCreateWithoutRestaurantInput = {
  city: string
  street: string
  zip: string
}

export type restaurantaddressCreateOneWithoutRestaurantInput = {
  create?: restaurantaddressCreateWithoutRestaurantInput
  connect?: restaurantaddressWhereUniqueInput
}

export type owneraccountCreateWithoutUserInput = {

}

export type owneraccountCreateManyWithoutUserInput = {
  create?: Enumerable<owneraccountCreateWithoutUserInput>
  connect?: Enumerable<owneraccountWhereUniqueInput>
}

export type orderCreateWithoutOrderitemInput = {
  date?: Date | string
  quantity?: number
  amount: number
  phone: string
  address: addressCreateOneWithoutOrderInput
  status?: statusCreateOneWithoutOrderInput
  user: userCreateOneWithoutOrderInput
}

export type orderCreateOneWithoutOrderitemInput = {
  create?: orderCreateWithoutOrderitemInput
  connect?: orderWhereUniqueInput
}

export type orderitemCreateWithoutDishInput = {
  quantity?: number
  order: orderCreateOneWithoutOrderitemInput
}

export type orderitemCreateManyWithoutDishInput = {
  create?: Enumerable<orderitemCreateWithoutDishInput>
  connect?: Enumerable<orderitemWhereUniqueInput>
}

export type dishCreateWithoutRestaurantInput = {
  name: string
  price: number
  ingredientchoice?: InputJsonValue | null
  additions?: InputJsonValue | null
  sizes?: dishCreatesizesInput
  ingredients?: dishCreateingredientsInput
  orderitem?: orderitemCreateManyWithoutDishInput
}

export type dishCreateManyWithoutRestaurantInput = {
  create?: Enumerable<dishCreateWithoutRestaurantInput>
  connect?: Enumerable<dishWhereUniqueInput>
}

export type userCreateWithoutReviewInput = {
  firstname: string
  lastname: string
  password: string
  email: string
  role?: string | null
  address?: addressCreateManyWithoutUserInput
  order?: orderCreateManyWithoutUserInput
  owneraccount?: owneraccountCreateManyWithoutUserInput
  restaurant?: restaurantCreateManyWithoutUserInput
}

export type userCreateOneWithoutReviewInput = {
  create?: userCreateWithoutReviewInput
  connect?: userWhereUniqueInput
}

export type reviewCreateWithoutRestaurantInput = {
  title: string
  description: string
  rating?: number | null
  user?: userCreateOneWithoutReviewInput
}

export type reviewCreateManyWithoutRestaurantInput = {
  create?: Enumerable<reviewCreateWithoutRestaurantInput>
  connect?: Enumerable<reviewWhereUniqueInput>
}

export type restaurantCreateWithoutUserInput = {
  name: string
  type: string
  phone: string
  delivery: number
  deliveryfee: number
  restaurantaddress: restaurantaddressCreateOneWithoutRestaurantInput
  dish?: dishCreateManyWithoutRestaurantInput
  review?: reviewCreateManyWithoutRestaurantInput
}

export type restaurantCreateManyWithoutUserInput = {
  create?: Enumerable<restaurantCreateWithoutUserInput>
  connect?: Enumerable<restaurantWhereUniqueInput>
}

export type restaurantCreateWithoutReviewInput = {
  name: string
  type: string
  phone: string
  delivery: number
  deliveryfee: number
  restaurantaddress: restaurantaddressCreateOneWithoutRestaurantInput
  user: userCreateOneWithoutRestaurantInput
  dish?: dishCreateManyWithoutRestaurantInput
}

export type restaurantCreateOneWithoutReviewInput = {
  create?: restaurantCreateWithoutReviewInput
  connect?: restaurantWhereUniqueInput
}

export type reviewCreateWithoutUserInput = {
  title: string
  description: string
  rating?: number | null
  restaurant: restaurantCreateOneWithoutReviewInput
}

export type reviewCreateManyWithoutUserInput = {
  create?: Enumerable<reviewCreateWithoutUserInput>
  connect?: Enumerable<reviewWhereUniqueInput>
}

export type userCreateWithoutOrderInput = {
  firstname: string
  lastname: string
  password: string
  email: string
  role?: string | null
  address?: addressCreateManyWithoutUserInput
  owneraccount?: owneraccountCreateManyWithoutUserInput
  restaurant?: restaurantCreateManyWithoutUserInput
  review?: reviewCreateManyWithoutUserInput
}

export type userCreateOneWithoutOrderInput = {
  create?: userCreateWithoutOrderInput
  connect?: userWhereUniqueInput
}

export type orderCreateWithoutAddressInput = {
  date?: Date | string
  quantity?: number
  amount: number
  phone: string
  status?: statusCreateOneWithoutOrderInput
  user: userCreateOneWithoutOrderInput
  orderitem?: orderitemCreateManyWithoutOrderInput
}

export type orderCreateManyWithoutAddressInput = {
  create?: Enumerable<orderCreateWithoutAddressInput>
  connect?: Enumerable<orderWhereUniqueInput>
}

export type addressCreateWithoutUserInput = {
  city: string
  street: string
  zip: string
  order?: orderCreateManyWithoutAddressInput
}

export type addressCreateManyWithoutUserInput = {
  create?: Enumerable<addressCreateWithoutUserInput>
  connect?: Enumerable<addressWhereUniqueInput>
}

export type userCreateWithoutRestaurantInput = {
  firstname: string
  lastname: string
  password: string
  email: string
  role?: string | null
  address?: addressCreateManyWithoutUserInput
  order?: orderCreateManyWithoutUserInput
  owneraccount?: owneraccountCreateManyWithoutUserInput
  review?: reviewCreateManyWithoutUserInput
}

export type userCreateOneWithoutRestaurantInput = {
  create?: userCreateWithoutRestaurantInput
  connect?: userWhereUniqueInput
}

export type restaurantCreateWithoutDishInput = {
  name: string
  type: string
  phone: string
  delivery: number
  deliveryfee: number
  restaurantaddress: restaurantaddressCreateOneWithoutRestaurantInput
  user: userCreateOneWithoutRestaurantInput
  review?: reviewCreateManyWithoutRestaurantInput
}

export type restaurantCreateOneWithoutDishInput = {
  create?: restaurantCreateWithoutDishInput
  connect?: restaurantWhereUniqueInput
}

export type dishCreateWithoutOrderitemInput = {
  name: string
  price: number
  ingredientchoice?: InputJsonValue | null
  additions?: InputJsonValue | null
  sizes?: dishCreatesizesInput
  ingredients?: dishCreateingredientsInput
  restaurant: restaurantCreateOneWithoutDishInput
}

export type dishCreateOneWithoutOrderitemInput = {
  create?: dishCreateWithoutOrderitemInput
  connect?: dishWhereUniqueInput
}

export type orderitemCreateWithoutOrderInput = {
  quantity?: number
  dish: dishCreateOneWithoutOrderitemInput
}

export type orderitemCreateManyWithoutOrderInput = {
  create?: Enumerable<orderitemCreateWithoutOrderInput>
  connect?: Enumerable<orderitemWhereUniqueInput>
}

export type orderCreateWithoutUserInput = {
  date?: Date | string
  quantity?: number
  amount: number
  phone: string
  address: addressCreateOneWithoutOrderInput
  status?: statusCreateOneWithoutOrderInput
  orderitem?: orderitemCreateManyWithoutOrderInput
}

export type orderCreateManyWithoutUserInput = {
  create?: Enumerable<orderCreateWithoutUserInput>
  connect?: Enumerable<orderWhereUniqueInput>
}

export type userCreateWithoutAddressInput = {
  firstname: string
  lastname: string
  password: string
  email: string
  role?: string | null
  order?: orderCreateManyWithoutUserInput
  owneraccount?: owneraccountCreateManyWithoutUserInput
  restaurant?: restaurantCreateManyWithoutUserInput
  review?: reviewCreateManyWithoutUserInput
}

export type userCreateOneWithoutAddressInput = {
  create?: userCreateWithoutAddressInput
  connect?: userWhereUniqueInput
}

export type addressCreateInput = {
  city: string
  street: string
  zip: string
  user?: userCreateOneWithoutAddressInput
  order?: orderCreateManyWithoutAddressInput
}

export type addressUpdateWithoutOrderDataInput = {
  city?: string
  street?: string
  zip?: string
  user?: userUpdateOneWithoutAddressInput
}

export type addressUpsertWithoutOrderInput = {
  update: addressUpdateWithoutOrderDataInput
  create: addressCreateWithoutOrderInput
}

export type addressUpdateOneRequiredWithoutOrderInput = {
  create?: addressCreateWithoutOrderInput
  connect?: addressWhereUniqueInput
  update?: addressUpdateWithoutOrderDataInput
  upsert?: addressUpsertWithoutOrderInput
}

export type statusUpdateWithoutOrderDataInput = {
  code?: string
  description?: string
}

export type statusUpsertWithoutOrderInput = {
  update: statusUpdateWithoutOrderDataInput
  create: statusCreateWithoutOrderInput
}

export type statusUpdateOneRequiredWithoutOrderInput = {
  create?: statusCreateWithoutOrderInput
  connect?: statusWhereUniqueInput
  update?: statusUpdateWithoutOrderDataInput
  upsert?: statusUpsertWithoutOrderInput
}

export type dishUpdatesizesInput = {
  set?: Enumerable<string>
}

export type dishUpdateingredientsInput = {
  set?: Enumerable<string>
}

export type restaurantaddressUpdateWithoutRestaurantDataInput = {
  city?: string
  street?: string
  zip?: string
}

export type restaurantaddressUpsertWithoutRestaurantInput = {
  update: restaurantaddressUpdateWithoutRestaurantDataInput
  create: restaurantaddressCreateWithoutRestaurantInput
}

export type restaurantaddressUpdateOneRequiredWithoutRestaurantInput = {
  create?: restaurantaddressCreateWithoutRestaurantInput
  connect?: restaurantaddressWhereUniqueInput
  update?: restaurantaddressUpdateWithoutRestaurantDataInput
  upsert?: restaurantaddressUpsertWithoutRestaurantInput
}

export type owneraccountUpdateWithoutUserDataInput = {

}

export type owneraccountUpdateWithWhereUniqueWithoutUserInput = {
  where: owneraccountWhereUniqueInput
  data: owneraccountUpdateWithoutUserDataInput
}

export type owneraccountScalarWhereInput = {
  AND?: Enumerable<owneraccountScalarWhereInput>
  OR?: Array<owneraccountScalarWhereInput>
  NOT?: Enumerable<owneraccountScalarWhereInput>
  id?: number | IntFilter
  client_id?: number | IntNullableFilter | null
}

export type owneraccountUpdateManyDataInput = {

}

export type owneraccountUpdateManyWithWhereNestedInput = {
  where: owneraccountScalarWhereInput
  data: owneraccountUpdateManyDataInput
}

export type owneraccountUpdateManyWithoutUserInput = {
  create?: Enumerable<owneraccountCreateWithoutUserInput>
  connect?: Enumerable<owneraccountWhereUniqueInput>
  set?: Enumerable<owneraccountWhereUniqueInput>
  disconnect?: Enumerable<owneraccountWhereUniqueInput>
  delete?: Enumerable<owneraccountWhereUniqueInput>
  update?: Enumerable<owneraccountUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<owneraccountUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<owneraccountScalarWhereInput>
}

export type orderUpdateWithoutOrderitemDataInput = {
  date?: Date | string
  quantity?: number
  amount?: number
  phone?: string
  address?: addressUpdateOneRequiredWithoutOrderInput
  status?: statusUpdateOneRequiredWithoutOrderInput
  user?: userUpdateOneRequiredWithoutOrderInput
}

export type orderUpsertWithoutOrderitemInput = {
  update: orderUpdateWithoutOrderitemDataInput
  create: orderCreateWithoutOrderitemInput
}

export type orderUpdateOneRequiredWithoutOrderitemInput = {
  create?: orderCreateWithoutOrderitemInput
  connect?: orderWhereUniqueInput
  update?: orderUpdateWithoutOrderitemDataInput
  upsert?: orderUpsertWithoutOrderitemInput
}

export type orderitemUpdateWithoutDishDataInput = {
  quantity?: number
  order?: orderUpdateOneRequiredWithoutOrderitemInput
}

export type orderitemUpdateWithWhereUniqueWithoutDishInput = {
  where: orderitemWhereUniqueInput
  data: orderitemUpdateWithoutDishDataInput
}

export type orderitemScalarWhereInput = {
  AND?: Enumerable<orderitemScalarWhereInput>
  OR?: Array<orderitemScalarWhereInput>
  NOT?: Enumerable<orderitemScalarWhereInput>
  id?: number | IntFilter
  quantity?: number | IntFilter
  item_id?: number | IntFilter
  order_id?: number | IntFilter
}

export type orderitemUpdateManyDataInput = {
  quantity?: number
}

export type orderitemUpdateManyWithWhereNestedInput = {
  where: orderitemScalarWhereInput
  data: orderitemUpdateManyDataInput
}

export type orderitemUpsertWithWhereUniqueWithoutDishInput = {
  where: orderitemWhereUniqueInput
  update: orderitemUpdateWithoutDishDataInput
  create: orderitemCreateWithoutDishInput
}

export type orderitemUpdateManyWithoutDishInput = {
  create?: Enumerable<orderitemCreateWithoutDishInput>
  connect?: Enumerable<orderitemWhereUniqueInput>
  set?: Enumerable<orderitemWhereUniqueInput>
  disconnect?: Enumerable<orderitemWhereUniqueInput>
  delete?: Enumerable<orderitemWhereUniqueInput>
  update?: Enumerable<orderitemUpdateWithWhereUniqueWithoutDishInput>
  updateMany?: Enumerable<orderitemUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<orderitemScalarWhereInput>
  upsert?: Enumerable<orderitemUpsertWithWhereUniqueWithoutDishInput>
}

export type dishUpdateWithoutRestaurantDataInput = {
  name?: string
  price?: number
  ingredientchoice?: InputJsonValue | null
  additions?: InputJsonValue | null
  sizes?: dishUpdatesizesInput
  ingredients?: dishUpdateingredientsInput
  orderitem?: orderitemUpdateManyWithoutDishInput
}

export type dishUpdateWithWhereUniqueWithoutRestaurantInput = {
  where: dishWhereUniqueInput
  data: dishUpdateWithoutRestaurantDataInput
}

export type dishScalarWhereInput = {
  AND?: Enumerable<dishScalarWhereInput>
  OR?: Array<dishScalarWhereInput>
  NOT?: Enumerable<dishScalarWhereInput>
  id?: number | IntFilter
  name?: string | StringFilter
  sizes?: Enumerable<string | StringNullableListFilter>
  ingredients?: Enumerable<string | StringNullableListFilter>
  price?: number | FloatFilter
  restaurant_id?: number | IntFilter
  ingredientchoice?: InputJsonValue | JsonNullableFilter | null
  additions?: InputJsonValue | JsonNullableFilter | null
}

export type dishUpdateManyDataInput = {
  name?: string
  price?: number
  ingredientchoice?: InputJsonValue | null
  additions?: InputJsonValue | null
  sizes?: dishUpdatesizesInput
  ingredients?: dishUpdateingredientsInput
}

export type dishUpdateManyWithWhereNestedInput = {
  where: dishScalarWhereInput
  data: dishUpdateManyDataInput
}

export type dishUpsertWithWhereUniqueWithoutRestaurantInput = {
  where: dishWhereUniqueInput
  update: dishUpdateWithoutRestaurantDataInput
  create: dishCreateWithoutRestaurantInput
}

export type dishUpdateManyWithoutRestaurantInput = {
  create?: Enumerable<dishCreateWithoutRestaurantInput>
  connect?: Enumerable<dishWhereUniqueInput>
  set?: Enumerable<dishWhereUniqueInput>
  disconnect?: Enumerable<dishWhereUniqueInput>
  delete?: Enumerable<dishWhereUniqueInput>
  update?: Enumerable<dishUpdateWithWhereUniqueWithoutRestaurantInput>
  updateMany?: Enumerable<dishUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<dishScalarWhereInput>
  upsert?: Enumerable<dishUpsertWithWhereUniqueWithoutRestaurantInput>
}

export type userUpdateWithoutReviewDataInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
  address?: addressUpdateManyWithoutUserInput
  order?: orderUpdateManyWithoutUserInput
  owneraccount?: owneraccountUpdateManyWithoutUserInput
  restaurant?: restaurantUpdateManyWithoutUserInput
}

export type userUpsertWithoutReviewInput = {
  update: userUpdateWithoutReviewDataInput
  create: userCreateWithoutReviewInput
}

export type userUpdateOneWithoutReviewInput = {
  create?: userCreateWithoutReviewInput
  connect?: userWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: userUpdateWithoutReviewDataInput
  upsert?: userUpsertWithoutReviewInput
}

export type reviewUpdateWithoutRestaurantDataInput = {
  title?: string
  description?: string
  rating?: number | null
  user?: userUpdateOneWithoutReviewInput
}

export type reviewUpdateWithWhereUniqueWithoutRestaurantInput = {
  where: reviewWhereUniqueInput
  data: reviewUpdateWithoutRestaurantDataInput
}

export type reviewScalarWhereInput = {
  AND?: Enumerable<reviewScalarWhereInput>
  OR?: Array<reviewScalarWhereInput>
  NOT?: Enumerable<reviewScalarWhereInput>
  id?: number | IntFilter
  title?: string | StringFilter
  description?: string | StringFilter
  rating?: number | IntNullableFilter | null
  user_id?: number | IntNullableFilter | null
  restaurant_id?: number | IntFilter
}

export type reviewUpdateManyDataInput = {
  title?: string
  description?: string
  rating?: number | null
}

export type reviewUpdateManyWithWhereNestedInput = {
  where: reviewScalarWhereInput
  data: reviewUpdateManyDataInput
}

export type reviewUpsertWithWhereUniqueWithoutRestaurantInput = {
  where: reviewWhereUniqueInput
  update: reviewUpdateWithoutRestaurantDataInput
  create: reviewCreateWithoutRestaurantInput
}

export type reviewUpdateManyWithoutRestaurantInput = {
  create?: Enumerable<reviewCreateWithoutRestaurantInput>
  connect?: Enumerable<reviewWhereUniqueInput>
  set?: Enumerable<reviewWhereUniqueInput>
  disconnect?: Enumerable<reviewWhereUniqueInput>
  delete?: Enumerable<reviewWhereUniqueInput>
  update?: Enumerable<reviewUpdateWithWhereUniqueWithoutRestaurantInput>
  updateMany?: Enumerable<reviewUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<reviewScalarWhereInput>
  upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutRestaurantInput>
}

export type restaurantUpdateWithoutUserDataInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
  restaurantaddress?: restaurantaddressUpdateOneRequiredWithoutRestaurantInput
  dish?: dishUpdateManyWithoutRestaurantInput
  review?: reviewUpdateManyWithoutRestaurantInput
}

export type restaurantUpdateWithWhereUniqueWithoutUserInput = {
  where: restaurantWhereUniqueInput
  data: restaurantUpdateWithoutUserDataInput
}

export type restaurantScalarWhereInput = {
  AND?: Enumerable<restaurantScalarWhereInput>
  OR?: Array<restaurantScalarWhereInput>
  NOT?: Enumerable<restaurantScalarWhereInput>
  id?: number | IntFilter
  name?: string | StringFilter
  type?: string | StringFilter
  phone?: string | StringFilter
  delivery?: number | IntFilter
  deliveryfee?: number | IntFilter
  owner_id?: number | IntFilter
  address_id?: number | IntFilter
}

export type restaurantUpdateManyDataInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
}

export type restaurantUpdateManyWithWhereNestedInput = {
  where: restaurantScalarWhereInput
  data: restaurantUpdateManyDataInput
}

export type restaurantUpsertWithWhereUniqueWithoutUserInput = {
  where: restaurantWhereUniqueInput
  update: restaurantUpdateWithoutUserDataInput
  create: restaurantCreateWithoutUserInput
}

export type restaurantUpdateManyWithoutUserInput = {
  create?: Enumerable<restaurantCreateWithoutUserInput>
  connect?: Enumerable<restaurantWhereUniqueInput>
  set?: Enumerable<restaurantWhereUniqueInput>
  disconnect?: Enumerable<restaurantWhereUniqueInput>
  delete?: Enumerable<restaurantWhereUniqueInput>
  update?: Enumerable<restaurantUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<restaurantUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<restaurantScalarWhereInput>
  upsert?: Enumerable<restaurantUpsertWithWhereUniqueWithoutUserInput>
}

export type restaurantUpdateWithoutReviewDataInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
  restaurantaddress?: restaurantaddressUpdateOneRequiredWithoutRestaurantInput
  user?: userUpdateOneRequiredWithoutRestaurantInput
  dish?: dishUpdateManyWithoutRestaurantInput
}

export type restaurantUpsertWithoutReviewInput = {
  update: restaurantUpdateWithoutReviewDataInput
  create: restaurantCreateWithoutReviewInput
}

export type restaurantUpdateOneRequiredWithoutReviewInput = {
  create?: restaurantCreateWithoutReviewInput
  connect?: restaurantWhereUniqueInput
  update?: restaurantUpdateWithoutReviewDataInput
  upsert?: restaurantUpsertWithoutReviewInput
}

export type reviewUpdateWithoutUserDataInput = {
  title?: string
  description?: string
  rating?: number | null
  restaurant?: restaurantUpdateOneRequiredWithoutReviewInput
}

export type reviewUpdateWithWhereUniqueWithoutUserInput = {
  where: reviewWhereUniqueInput
  data: reviewUpdateWithoutUserDataInput
}

export type reviewUpsertWithWhereUniqueWithoutUserInput = {
  where: reviewWhereUniqueInput
  update: reviewUpdateWithoutUserDataInput
  create: reviewCreateWithoutUserInput
}

export type reviewUpdateManyWithoutUserInput = {
  create?: Enumerable<reviewCreateWithoutUserInput>
  connect?: Enumerable<reviewWhereUniqueInput>
  set?: Enumerable<reviewWhereUniqueInput>
  disconnect?: Enumerable<reviewWhereUniqueInput>
  delete?: Enumerable<reviewWhereUniqueInput>
  update?: Enumerable<reviewUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<reviewUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<reviewScalarWhereInput>
  upsert?: Enumerable<reviewUpsertWithWhereUniqueWithoutUserInput>
}

export type userUpdateWithoutOrderDataInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
  address?: addressUpdateManyWithoutUserInput
  owneraccount?: owneraccountUpdateManyWithoutUserInput
  restaurant?: restaurantUpdateManyWithoutUserInput
  review?: reviewUpdateManyWithoutUserInput
}

export type userUpsertWithoutOrderInput = {
  update: userUpdateWithoutOrderDataInput
  create: userCreateWithoutOrderInput
}

export type userUpdateOneRequiredWithoutOrderInput = {
  create?: userCreateWithoutOrderInput
  connect?: userWhereUniqueInput
  update?: userUpdateWithoutOrderDataInput
  upsert?: userUpsertWithoutOrderInput
}

export type orderUpdateWithoutAddressDataInput = {
  date?: Date | string
  quantity?: number
  amount?: number
  phone?: string
  status?: statusUpdateOneRequiredWithoutOrderInput
  user?: userUpdateOneRequiredWithoutOrderInput
  orderitem?: orderitemUpdateManyWithoutOrderInput
}

export type orderUpdateWithWhereUniqueWithoutAddressInput = {
  where: orderWhereUniqueInput
  data: orderUpdateWithoutAddressDataInput
}

export type orderScalarWhereInput = {
  AND?: Enumerable<orderScalarWhereInput>
  OR?: Array<orderScalarWhereInput>
  NOT?: Enumerable<orderScalarWhereInput>
  id?: number | IntFilter
  user_id?: number | IntFilter
  date?: Date | string | DateTimeFilter
  status_id?: number | IntFilter
  quantity?: number | IntFilter
  amount?: number | FloatFilter
  address_id?: number | IntFilter
  phone?: string | StringFilter
}

export type orderUpdateManyDataInput = {
  date?: Date | string
  quantity?: number
  amount?: number
  phone?: string
}

export type orderUpdateManyWithWhereNestedInput = {
  where: orderScalarWhereInput
  data: orderUpdateManyDataInput
}

export type orderUpsertWithWhereUniqueWithoutAddressInput = {
  where: orderWhereUniqueInput
  update: orderUpdateWithoutAddressDataInput
  create: orderCreateWithoutAddressInput
}

export type orderUpdateManyWithoutAddressInput = {
  create?: Enumerable<orderCreateWithoutAddressInput>
  connect?: Enumerable<orderWhereUniqueInput>
  set?: Enumerable<orderWhereUniqueInput>
  disconnect?: Enumerable<orderWhereUniqueInput>
  delete?: Enumerable<orderWhereUniqueInput>
  update?: Enumerable<orderUpdateWithWhereUniqueWithoutAddressInput>
  updateMany?: Enumerable<orderUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<orderScalarWhereInput>
  upsert?: Enumerable<orderUpsertWithWhereUniqueWithoutAddressInput>
}

export type addressUpdateWithoutUserDataInput = {
  city?: string
  street?: string
  zip?: string
  order?: orderUpdateManyWithoutAddressInput
}

export type addressUpdateWithWhereUniqueWithoutUserInput = {
  where: addressWhereUniqueInput
  data: addressUpdateWithoutUserDataInput
}

export type addressScalarWhereInput = {
  AND?: Enumerable<addressScalarWhereInput>
  OR?: Array<addressScalarWhereInput>
  NOT?: Enumerable<addressScalarWhereInput>
  id?: number | IntFilter
  city?: string | StringFilter
  street?: string | StringFilter
  zip?: string | StringFilter
  user_id?: number | IntNullableFilter | null
}

export type addressUpdateManyDataInput = {
  city?: string
  street?: string
  zip?: string
}

export type addressUpdateManyWithWhereNestedInput = {
  where: addressScalarWhereInput
  data: addressUpdateManyDataInput
}

export type addressUpsertWithWhereUniqueWithoutUserInput = {
  where: addressWhereUniqueInput
  update: addressUpdateWithoutUserDataInput
  create: addressCreateWithoutUserInput
}

export type addressUpdateManyWithoutUserInput = {
  create?: Enumerable<addressCreateWithoutUserInput>
  connect?: Enumerable<addressWhereUniqueInput>
  set?: Enumerable<addressWhereUniqueInput>
  disconnect?: Enumerable<addressWhereUniqueInput>
  delete?: Enumerable<addressWhereUniqueInput>
  update?: Enumerable<addressUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<addressUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<addressScalarWhereInput>
  upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutUserInput>
}

export type userUpdateWithoutRestaurantDataInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
  address?: addressUpdateManyWithoutUserInput
  order?: orderUpdateManyWithoutUserInput
  owneraccount?: owneraccountUpdateManyWithoutUserInput
  review?: reviewUpdateManyWithoutUserInput
}

export type userUpsertWithoutRestaurantInput = {
  update: userUpdateWithoutRestaurantDataInput
  create: userCreateWithoutRestaurantInput
}

export type userUpdateOneRequiredWithoutRestaurantInput = {
  create?: userCreateWithoutRestaurantInput
  connect?: userWhereUniqueInput
  update?: userUpdateWithoutRestaurantDataInput
  upsert?: userUpsertWithoutRestaurantInput
}

export type restaurantUpdateWithoutDishDataInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
  restaurantaddress?: restaurantaddressUpdateOneRequiredWithoutRestaurantInput
  user?: userUpdateOneRequiredWithoutRestaurantInput
  review?: reviewUpdateManyWithoutRestaurantInput
}

export type restaurantUpsertWithoutDishInput = {
  update: restaurantUpdateWithoutDishDataInput
  create: restaurantCreateWithoutDishInput
}

export type restaurantUpdateOneRequiredWithoutDishInput = {
  create?: restaurantCreateWithoutDishInput
  connect?: restaurantWhereUniqueInput
  update?: restaurantUpdateWithoutDishDataInput
  upsert?: restaurantUpsertWithoutDishInput
}

export type dishUpdateWithoutOrderitemDataInput = {
  name?: string
  price?: number
  ingredientchoice?: InputJsonValue | null
  additions?: InputJsonValue | null
  sizes?: dishUpdatesizesInput
  ingredients?: dishUpdateingredientsInput
  restaurant?: restaurantUpdateOneRequiredWithoutDishInput
}

export type dishUpsertWithoutOrderitemInput = {
  update: dishUpdateWithoutOrderitemDataInput
  create: dishCreateWithoutOrderitemInput
}

export type dishUpdateOneRequiredWithoutOrderitemInput = {
  create?: dishCreateWithoutOrderitemInput
  connect?: dishWhereUniqueInput
  update?: dishUpdateWithoutOrderitemDataInput
  upsert?: dishUpsertWithoutOrderitemInput
}

export type orderitemUpdateWithoutOrderDataInput = {
  quantity?: number
  dish?: dishUpdateOneRequiredWithoutOrderitemInput
}

export type orderitemUpdateWithWhereUniqueWithoutOrderInput = {
  where: orderitemWhereUniqueInput
  data: orderitemUpdateWithoutOrderDataInput
}

export type orderitemUpsertWithWhereUniqueWithoutOrderInput = {
  where: orderitemWhereUniqueInput
  update: orderitemUpdateWithoutOrderDataInput
  create: orderitemCreateWithoutOrderInput
}

export type orderitemUpdateManyWithoutOrderInput = {
  create?: Enumerable<orderitemCreateWithoutOrderInput>
  connect?: Enumerable<orderitemWhereUniqueInput>
  set?: Enumerable<orderitemWhereUniqueInput>
  disconnect?: Enumerable<orderitemWhereUniqueInput>
  delete?: Enumerable<orderitemWhereUniqueInput>
  update?: Enumerable<orderitemUpdateWithWhereUniqueWithoutOrderInput>
  updateMany?: Enumerable<orderitemUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<orderitemScalarWhereInput>
  upsert?: Enumerable<orderitemUpsertWithWhereUniqueWithoutOrderInput>
}

export type orderUpdateWithoutUserDataInput = {
  date?: Date | string
  quantity?: number
  amount?: number
  phone?: string
  address?: addressUpdateOneRequiredWithoutOrderInput
  status?: statusUpdateOneRequiredWithoutOrderInput
  orderitem?: orderitemUpdateManyWithoutOrderInput
}

export type orderUpdateWithWhereUniqueWithoutUserInput = {
  where: orderWhereUniqueInput
  data: orderUpdateWithoutUserDataInput
}

export type orderUpsertWithWhereUniqueWithoutUserInput = {
  where: orderWhereUniqueInput
  update: orderUpdateWithoutUserDataInput
  create: orderCreateWithoutUserInput
}

export type orderUpdateManyWithoutUserInput = {
  create?: Enumerable<orderCreateWithoutUserInput>
  connect?: Enumerable<orderWhereUniqueInput>
  set?: Enumerable<orderWhereUniqueInput>
  disconnect?: Enumerable<orderWhereUniqueInput>
  delete?: Enumerable<orderWhereUniqueInput>
  update?: Enumerable<orderUpdateWithWhereUniqueWithoutUserInput>
  updateMany?: Enumerable<orderUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<orderScalarWhereInput>
  upsert?: Enumerable<orderUpsertWithWhereUniqueWithoutUserInput>
}

export type userUpdateWithoutAddressDataInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
  order?: orderUpdateManyWithoutUserInput
  owneraccount?: owneraccountUpdateManyWithoutUserInput
  restaurant?: restaurantUpdateManyWithoutUserInput
  review?: reviewUpdateManyWithoutUserInput
}

export type userUpsertWithoutAddressInput = {
  update: userUpdateWithoutAddressDataInput
  create: userCreateWithoutAddressInput
}

export type userUpdateOneWithoutAddressInput = {
  create?: userCreateWithoutAddressInput
  connect?: userWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: userUpdateWithoutAddressDataInput
  upsert?: userUpsertWithoutAddressInput
}

export type addressUpdateInput = {
  city?: string
  street?: string
  zip?: string
  user?: userUpdateOneWithoutAddressInput
  order?: orderUpdateManyWithoutAddressInput
}

export type addressUpdateManyMutationInput = {
  city?: string
  street?: string
  zip?: string
}

export type dishCreateInput = {
  name: string
  price: number
  ingredientchoice?: InputJsonValue | null
  additions?: InputJsonValue | null
  sizes?: dishCreatesizesInput
  ingredients?: dishCreateingredientsInput
  restaurant: restaurantCreateOneWithoutDishInput
  orderitem?: orderitemCreateManyWithoutDishInput
}

export type dishUpdateInput = {
  name?: string
  price?: number
  ingredientchoice?: InputJsonValue | null
  additions?: InputJsonValue | null
  sizes?: dishUpdatesizesInput
  ingredients?: dishUpdateingredientsInput
  restaurant?: restaurantUpdateOneRequiredWithoutDishInput
  orderitem?: orderitemUpdateManyWithoutDishInput
}

export type dishUpdateManyMutationInput = {
  name?: string
  price?: number
  ingredientchoice?: InputJsonValue | null
  additions?: InputJsonValue | null
  sizes?: dishUpdatesizesInput
  ingredients?: dishUpdateingredientsInput
}

export type orderCreateInput = {
  date?: Date | string
  quantity?: number
  amount: number
  phone: string
  address: addressCreateOneWithoutOrderInput
  status?: statusCreateOneWithoutOrderInput
  user: userCreateOneWithoutOrderInput
  orderitem?: orderitemCreateManyWithoutOrderInput
}

export type orderUpdateInput = {
  date?: Date | string
  quantity?: number
  amount?: number
  phone?: string
  address?: addressUpdateOneRequiredWithoutOrderInput
  status?: statusUpdateOneRequiredWithoutOrderInput
  user?: userUpdateOneRequiredWithoutOrderInput
  orderitem?: orderitemUpdateManyWithoutOrderInput
}

export type orderUpdateManyMutationInput = {
  date?: Date | string
  quantity?: number
  amount?: number
  phone?: string
}

export type orderitemCreateInput = {
  quantity?: number
  dish: dishCreateOneWithoutOrderitemInput
  order: orderCreateOneWithoutOrderitemInput
}

export type orderitemUpdateInput = {
  quantity?: number
  dish?: dishUpdateOneRequiredWithoutOrderitemInput
  order?: orderUpdateOneRequiredWithoutOrderitemInput
}

export type orderitemUpdateManyMutationInput = {
  quantity?: number
}

export type userCreateWithoutOwneraccountInput = {
  firstname: string
  lastname: string
  password: string
  email: string
  role?: string | null
  address?: addressCreateManyWithoutUserInput
  order?: orderCreateManyWithoutUserInput
  restaurant?: restaurantCreateManyWithoutUserInput
  review?: reviewCreateManyWithoutUserInput
}

export type userCreateOneWithoutOwneraccountInput = {
  create?: userCreateWithoutOwneraccountInput
  connect?: userWhereUniqueInput
}

export type owneraccountCreateInput = {
  user?: userCreateOneWithoutOwneraccountInput
}

export type userUpdateWithoutOwneraccountDataInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
  address?: addressUpdateManyWithoutUserInput
  order?: orderUpdateManyWithoutUserInput
  restaurant?: restaurantUpdateManyWithoutUserInput
  review?: reviewUpdateManyWithoutUserInput
}

export type userUpsertWithoutOwneraccountInput = {
  update: userUpdateWithoutOwneraccountDataInput
  create: userCreateWithoutOwneraccountInput
}

export type userUpdateOneWithoutOwneraccountInput = {
  create?: userCreateWithoutOwneraccountInput
  connect?: userWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: userUpdateWithoutOwneraccountDataInput
  upsert?: userUpsertWithoutOwneraccountInput
}

export type owneraccountUpdateInput = {
  user?: userUpdateOneWithoutOwneraccountInput
}

export type owneraccountUpdateManyMutationInput = {

}

export type restaurantCreateInput = {
  name: string
  type: string
  phone: string
  delivery: number
  deliveryfee: number
  restaurantaddress: restaurantaddressCreateOneWithoutRestaurantInput
  user: userCreateOneWithoutRestaurantInput
  dish?: dishCreateManyWithoutRestaurantInput
  review?: reviewCreateManyWithoutRestaurantInput
}

export type restaurantUpdateInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
  restaurantaddress?: restaurantaddressUpdateOneRequiredWithoutRestaurantInput
  user?: userUpdateOneRequiredWithoutRestaurantInput
  dish?: dishUpdateManyWithoutRestaurantInput
  review?: reviewUpdateManyWithoutRestaurantInput
}

export type restaurantUpdateManyMutationInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
}

export type restaurantCreateWithoutRestaurantaddressInput = {
  name: string
  type: string
  phone: string
  delivery: number
  deliveryfee: number
  user: userCreateOneWithoutRestaurantInput
  dish?: dishCreateManyWithoutRestaurantInput
  review?: reviewCreateManyWithoutRestaurantInput
}

export type restaurantCreateManyWithoutRestaurantaddressInput = {
  create?: Enumerable<restaurantCreateWithoutRestaurantaddressInput>
  connect?: Enumerable<restaurantWhereUniqueInput>
}

export type restaurantaddressCreateInput = {
  city: string
  street: string
  zip: string
  restaurant?: restaurantCreateManyWithoutRestaurantaddressInput
}

export type restaurantUpdateWithoutRestaurantaddressDataInput = {
  name?: string
  type?: string
  phone?: string
  delivery?: number
  deliveryfee?: number
  user?: userUpdateOneRequiredWithoutRestaurantInput
  dish?: dishUpdateManyWithoutRestaurantInput
  review?: reviewUpdateManyWithoutRestaurantInput
}

export type restaurantUpdateWithWhereUniqueWithoutRestaurantaddressInput = {
  where: restaurantWhereUniqueInput
  data: restaurantUpdateWithoutRestaurantaddressDataInput
}

export type restaurantUpsertWithWhereUniqueWithoutRestaurantaddressInput = {
  where: restaurantWhereUniqueInput
  update: restaurantUpdateWithoutRestaurantaddressDataInput
  create: restaurantCreateWithoutRestaurantaddressInput
}

export type restaurantUpdateManyWithoutRestaurantaddressInput = {
  create?: Enumerable<restaurantCreateWithoutRestaurantaddressInput>
  connect?: Enumerable<restaurantWhereUniqueInput>
  set?: Enumerable<restaurantWhereUniqueInput>
  disconnect?: Enumerable<restaurantWhereUniqueInput>
  delete?: Enumerable<restaurantWhereUniqueInput>
  update?: Enumerable<restaurantUpdateWithWhereUniqueWithoutRestaurantaddressInput>
  updateMany?: Enumerable<restaurantUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<restaurantScalarWhereInput>
  upsert?: Enumerable<restaurantUpsertWithWhereUniqueWithoutRestaurantaddressInput>
}

export type restaurantaddressUpdateInput = {
  city?: string
  street?: string
  zip?: string
  restaurant?: restaurantUpdateManyWithoutRestaurantaddressInput
}

export type restaurantaddressUpdateManyMutationInput = {
  city?: string
  street?: string
  zip?: string
}

export type reviewCreateInput = {
  title: string
  description: string
  rating?: number | null
  restaurant: restaurantCreateOneWithoutReviewInput
  user?: userCreateOneWithoutReviewInput
}

export type reviewUpdateInput = {
  title?: string
  description?: string
  rating?: number | null
  restaurant?: restaurantUpdateOneRequiredWithoutReviewInput
  user?: userUpdateOneWithoutReviewInput
}

export type reviewUpdateManyMutationInput = {
  title?: string
  description?: string
  rating?: number | null
}

export type orderCreateWithoutStatusInput = {
  date?: Date | string
  quantity?: number
  amount: number
  phone: string
  address: addressCreateOneWithoutOrderInput
  user: userCreateOneWithoutOrderInput
  orderitem?: orderitemCreateManyWithoutOrderInput
}

export type orderCreateManyWithoutStatusInput = {
  create?: Enumerable<orderCreateWithoutStatusInput>
  connect?: Enumerable<orderWhereUniqueInput>
}

export type statusCreateInput = {
  code: string
  description: string
  order?: orderCreateManyWithoutStatusInput
}

export type orderUpdateWithoutStatusDataInput = {
  date?: Date | string
  quantity?: number
  amount?: number
  phone?: string
  address?: addressUpdateOneRequiredWithoutOrderInput
  user?: userUpdateOneRequiredWithoutOrderInput
  orderitem?: orderitemUpdateManyWithoutOrderInput
}

export type orderUpdateWithWhereUniqueWithoutStatusInput = {
  where: orderWhereUniqueInput
  data: orderUpdateWithoutStatusDataInput
}

export type orderUpsertWithWhereUniqueWithoutStatusInput = {
  where: orderWhereUniqueInput
  update: orderUpdateWithoutStatusDataInput
  create: orderCreateWithoutStatusInput
}

export type orderUpdateManyWithoutStatusInput = {
  create?: Enumerable<orderCreateWithoutStatusInput>
  connect?: Enumerable<orderWhereUniqueInput>
  set?: Enumerable<orderWhereUniqueInput>
  disconnect?: Enumerable<orderWhereUniqueInput>
  delete?: Enumerable<orderWhereUniqueInput>
  update?: Enumerable<orderUpdateWithWhereUniqueWithoutStatusInput>
  updateMany?: Enumerable<orderUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<orderScalarWhereInput>
  upsert?: Enumerable<orderUpsertWithWhereUniqueWithoutStatusInput>
}

export type statusUpdateInput = {
  code?: string
  description?: string
  order?: orderUpdateManyWithoutStatusInput
}

export type statusUpdateManyMutationInput = {
  code?: string
  description?: string
}

export type userCreateInput = {
  firstname: string
  lastname: string
  password: string
  email: string
  role?: string | null
  address?: addressCreateManyWithoutUserInput
  order?: orderCreateManyWithoutUserInput
  owneraccount?: owneraccountCreateManyWithoutUserInput
  restaurant?: restaurantCreateManyWithoutUserInput
  review?: reviewCreateManyWithoutUserInput
}

export type userUpdateInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
  address?: addressUpdateManyWithoutUserInput
  order?: orderUpdateManyWithoutUserInput
  owneraccount?: owneraccountUpdateManyWithoutUserInput
  restaurant?: restaurantUpdateManyWithoutUserInput
  review?: reviewUpdateManyWithoutUserInput
}

export type userUpdateManyMutationInput = {
  firstname?: string
  lastname?: string
  password?: string
  email?: string
  role?: string | null
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
